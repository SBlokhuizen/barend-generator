<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Barend Generator</title>
<style>
  :root{
    --bg:#0f1226;
    --card:#161a36;
    --accent:#6ee7f5;
    --accent-2:#9b8cff;
    --accent-3:#4ade80;
    --muted:#9aa3b2;
    --text:#e8ebff;
    --danger:#ff4d6d;
    --shadow: 0 20px 60px rgba(0,0,0,.45), 0 2px 10px rgba(0,0,0,.25);
    --radius:16px;
    --morph-y-offset: -72.5%;
  }
  @media (min-width: 769px) {
    :root {
        --morph-y-offset: -77.5%;
    }
}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;padding:0}
  body{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    background:
      radial-gradient(1200px 600px at 10% -10%, #1a1f46 0%, transparent 60%),
      radial-gradient(900px 500px at 110% 10%, #1a2b4a 0%, transparent 60%),
      linear-gradient(180deg, #0b0e1d 0%, #0f1226 60%, #0b0e1d 100%);
    color:var(--text);
    font:16px/1.5 "Inter", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .wrap{
    width: min(880px, calc(100% - 48px));
    max-width:880px;
    display:grid;
    gap:22px;
    align-content:center;
    margin:0;
  }

  .card{
    background:
      linear-gradient(135deg, rgba(110,231,245,.08), rgba(155,140,255,.06)) padding-box,
      linear-gradient(135deg, rgba(110,231,245,.35), rgba(155,140,255,.35)) border-box;
    border:1px solid transparent;
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:18px;
    backdrop-filter: blur(10px);
  }

  .title {
    font-weight:800;
    letter-spacing:.3px;
    font-size: clamp(36px, 2.4vw, 30px);
    margin:0 0 8px 0;
    display: flex;
    align-items: center;
    background: var(--accent);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }

  .title-text {
    background: none;
    -webkit-background-clip: inherit;
    background-clip: inherit;
    color: inherit;
  }

  .morphing-letter {
    position: relative;
    display: inline-block;
    width: 0.6em;
    overflow: hidden;
  }

  .letter-container {
    position: relative;
    display: inline-block;
  }

  .letter-a, .letter-e {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateY(var(--morph-y-offset));
    -webkit-background-clip: text;
    background-clip: text;
    color: var(--accent);
    transition: all 0.8s cubic-bezier(0.4, 0.0, 0.2, 1);
  }

  .letter-a { opacity: 1; transform: translateY(var(--morph-y-offset)) scale(1); }
  .letter-e { opacity: 0; transform: translateY(var(--morph-y-offset)) scale(0.3); }

  /* Morphing states */
  .morph-state-barend .pos1 .letter-a { opacity: 1; transform: translateY(var(--morph-y-offset)) scale(1) ; }
  .morph-state-barend .pos1 .letter-e { opacity: 0; transform: translateY(var(--morph-y-offset)) scale(0.3) ; }
  .morph-state-barend .pos2 .letter-a { opacity: 0; transform: translateY(var(--morph-y-offset)) scale(0.3) ; }
  .morph-state-barend .pos2 .letter-e { opacity: 1; transform: translateY(var(--morph-y-offset)) scale(1); }

  .morph-state-barand .pos1 .letter-a { opacity: 1; transform: translateY(var(--morph-y-offset)) scale(1) ; }
  .morph-state-barand .pos1 .letter-e { opacity: 0; transform: translateY(var(--morph-y-offset)) scale(0.3) ; }
  .morph-state-barand .pos2 .letter-a { opacity: 1; transform: translateY(var(--morph-y-offset)) scale(1) ; }
  .morph-state-barand .pos2 .letter-e { opacity: 0; transform: translateY(var(--morph-y-offset)) scale(0.3) ; }

  .morph-state-berand .pos1 .letter-a { opacity: 0; transform: translateY(var(--morph-y-offset)) scale(0.3) ; }
  .morph-state-berand .pos1 .letter-e { opacity: 1; transform: translateY(var(--morph-y-offset)) scale(1) ; }
  .morph-state-berand .pos2 .letter-a { opacity: 1; transform: translateY(var(--morph-y-offset)) scale(1) ; }
  .morph-state-berand .pos2 .letter-e { opacity: 0; transform: translateY(var(--morph-y-offset)) scale(0.3) ; }

  .morph-state-berend .pos1 .letter-a { opacity: 0; transform: translateY(var(--morph-y-offset)) scale(0.3) ; }
  .morph-state-berend .pos1 .letter-e { opacity: 1; transform: translateY(var(--morph-y-offset)) scale(1) ; }
  .morph-state-berend .pos2 .letter-a { opacity: 0; transform: translateY(var(--morph-y-offset)) scale(0.3) ; }
  .morph-state-berend .pos2 .letter-e { opacity: 1; transform: translateY(var(--morph-y-offset)) scale(1) ; }

  /* Primary controls in a row */
  form{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
    margin-top:8px;
  }
  input[type="text"]{
    flex:1 1 320px;
    min-width:0;
    padding:12px 14px;
    font-size:18px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.08);
    background:#0e1230;
    color:var(--text);
    outline:none;
    font-weight:600;
  }
  input[type="text"]:focus{
    border-color: var(--accent);
    box-shadow: 0 0 0 6px rgba(110,231,245,.08);
  }

  .btn{
    appearance:none;border:0;cursor:pointer;
    padding:20px 32px;border-radius:12px;
    font-weight:700;letter-spacing:.3px;
    transition:transform .06s ease, box-shadow .18s ease;
    white-space:nowrap;
    flex:0 0 auto;
    font-size:18px;
  }
  .btn:active{transform:translateY(1px)}
  .btn.primary{
    color:#02131a;background:linear-gradient(135deg,var(--accent),#6fd4ff);
    box-shadow:0 10px 30px rgba(110,231,245,.22);
  }
  .btn.ghost{
    color:#dbe7ff;background:rgba(255,255,255,.04);
    border:1px solid rgba(255,255,255,.06);
  }
  .btn.stop{
    color:#33000b;background:linear-gradient(135deg,#ff97aa,var(--danger));
    box-shadow:0 10px 30px rgba(255,77,109,.12);
  }

  .grid{
    margin-top:12px;
    display:grid;
    gap:14px;
  }

  .cell{
    border-radius:14px;
    padding:16px;
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08);
    text-align:center;
    font-weight:900;
    font-size: clamp(18px, 3.2vw, 32px);
    letter-spacing:.6px;
    position:relative;
    overflow:hidden;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    line-height:1.1;
    white-space: nowrap;
  }
  .cell::after{
    content:"";
    position:absolute; inset:0;
    background: radial-gradient(600px 180px at var(--x, 50%) var(--y, 50%), rgba(110,231,245,.12), transparent 60%);
    opacity:0; transition:opacity .25s ease;
  }
  .cell:hover::after{opacity:1}
  .cell.active{
    background:
      linear-gradient(180deg, rgba(155,140,255,.18), rgba(110,231,245,.12));
    border-color: rgba(110,231,245,.65);
    box-shadow: 0 0 0 6px rgba(110,231,245,.08), inset 0 0 40px rgba(110,231,245,.06);
  }

  /* 3D */
  #canvas-container {
    height: clamp(320px, 60vh, 600px);
    position: relative;
    border-radius: 16px;
    overflow: hidden;
    background: linear-gradient(135deg, rgba(0,0,0,0.25), rgba(0,0,0,0.08));
  }
  #three-canvas { width:100%; height:100%; display:block; touch-action:none; background:transparent; }

  .canvas-overlay {
    position:absolute; top:12px; left:12px; right:12px;
    display:flex; justify-content:space-between; align-items:flex-start;
    pointer-events:none; z-index:10;
  }
  .canvas-controls {
    background: rgba(0,0,0,0.68);
    padding:8px 12px; border-radius:12px; font-size:12px; color:#c4cbe0;
    pointer-events:auto; border:1px solid rgba(255,255,255,.06); backdrop-filter:blur(6px);
  }
  .desktop-hint{display:block} .mobile-hint{display:none}
  @media (max-width:768px){ .desktop-hint{display:none} .mobile-hint{display:block} }

  .dimension-info{
    background: rgba(110,231,245,0.08);
    border:1px solid rgba(110,231,245,0.22);
    padding:8px 12px; border-radius:12px; font-size:13px; font-weight:600;
    color:#dcecff; backdrop-filter:blur(4px);
  }

  dialog::backdrop{background:linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,.65))}
  dialog{border:0;border-radius:16px;padding:0;overflow:hidden;background:linear-gradient(180deg,#1b1f45,#131736);color:var(--text);box-shadow:var(--shadow)}
  .modal-head{padding:14px 16px;background:linear-gradient(90deg, rgba(255,77,109,.18), rgba(110,231,245,.06));display:flex;align-items:center}
  .modal-title{font-size:18px;font-weight:900;color:#fff}
  .modal-body{padding:14px 16px;color:#dfe5ff}
  .modal-actions{padding:12px 16px;display:flex;justify-content:flex-end;background:#0e1230}
  .kbd{font:600 12px ui-monospace,Menlo,Monaco,monospace;background:#0e1230;border:1px solid rgba(255,255,255,.12);padding:2px 6px;border-radius:6px;color:#b8c0de}

  @media (max-width:680px){
    .wrap{width:calc(100% - 24px)}
    form{gap:8px}
    input[type="text"]{flex-basis:100%}
    .btn{padding:12px 16px; font-size:16px;}
  }
</style>
</head>
<body>
  <div class="wrap" role="main">
      <h1 id="title" class="title">
        <span class="title-text">B</span>
        <div class="morphing-letter pos1">
          <div class="letter-container">
            <span class="letter-a">a</span>
            <span class="letter-e">e</span>
          </div>
        </div>
        <span class="title-text">r</span>
        <div class="morphing-letter pos2">
          <div class="letter-container">
            <span class="letter-a">a</span>
            <span class="letter-e">e</span>
          </div>
        </div>
        <span class="title-text">nd Generator</span>
      </h1>
    <header class="card" aria-labelledby="title">
      <form id="scramble-form" autocomplete="off" novalidate>
        <input id="word" name="word" type="text" spellcheck="false" placeholder="bijv. Barend" maxlength="48" />
        <button type="submit" class="btn primary" id="generate">Genereren</button>
        <button type="button" class="btn ghost" id="speak">Opnieuw</button>
        <button type="button" class="btn stop" id="stop">Stop</button>
      </form>
    </header>

    <section id="output-card" class="card" aria-live="polite" style="display:none;">
      <div id="grid" class="grid" aria-hidden="false"></div>
      <div id="canvas-container" style="display:none;">
        <canvas id="three-canvas" role="img" aria-label="3D knoppen canvas"></canvas>
        <div class="canvas-overlay">
          <div class="canvas-controls">
            <span class="desktop-hint">Sleep = roteren • Scroll/knijp = zoomen</span>
            <span class="mobile-hint">Sleep = roteren • Knijp = zoomen</span>
          </div>
          <div class="dimension-info" id="dimension-info"></div>
        </div>
      </div>
    </section>
  </div>

  <dialog id="modal" aria-modal="true" role="dialog">
    <div class="modal-head"><div class="modal-title">NEEHEE</div></div>
    <div class="modal-body">
      <p>Het woord moet minstens twee verschillende klinkergroepen bevatten. Geldige groepen: <span class="kbd">a aa e ee i ie o oo u uu oe eu ui ij ei ai au ou</span>.</p>
    </div>
    <div class="modal-actions"><button class="btn primary" id="close-modal">OK</button></div>
  </dialog>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(() => {
  // Morphing title animation
  const title = document.getElementById('title');
  const morphStates = ['morph-state-barend', 'morph-state-barand', 'morph-state-berand', 'morph-state-berend'];
  let currentMorphState = 0;
  
  function morphTitle() {
    // Remove current state
    title.classList.remove(morphStates[currentMorphState]);
    
    // Move to next state
    currentMorphState = (currentMorphState + 1) % morphStates.length;
    
    // Add new state
    title.classList.add(morphStates[currentMorphState]);
  }
  
  // Initialize with first state
  title.classList.add(morphStates[currentMorphState]);
  
  // Start morphing animation
  setInterval(morphTitle, 2000);

  const BUTTON_DEPTH = 0.28;
  const TEXT_Z_OFFSET = 0.08;
  const vowelGroups = ['aa','ee','ii','ie','oo','uu','oe','eu','ui','ij','ei','ai','au','ou','a','e','i','o','u'];

  const form = document.getElementById('scramble-form');
  const input = document.getElementById('word');
  const grid = document.getElementById('grid');
  const outputCard = document.getElementById('output-card');
  const canvasContainer = document.getElementById('canvas-container');
  const canvas = document.getElementById('three-canvas');
  const dimensionInfo = document.getElementById('dimension-info');
  const btnSpeak = document.getElementById('speak');
  const btnStop = document.getElementById('stop');
  const modal = document.getElementById('modal');
  const closeModal = document.getElementById('close-modal');

  let scene, camera, renderer;
  let wordButtons = [];
  let speaking = false;
  let raycaster, mouse;

  function initThreeJS(){
    if (scene) return;
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f1226);

    renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / Math.max(1, canvas.clientHeight), 0.1, 1000);
    camera.position.set(0,0,8);
    camera.lookAt(0,0,0);

    const ambientLight = new THREE.AmbientLight(0x6ee7f5, 0.45);
    scene.add(ambientLight);
    const dir = new THREE.DirectionalLight(0x9b8cff, 0.9);
    dir.position.set(5,10,5);
    dir.castShadow = true;
    scene.add(dir);

    let isRot = false;
    let rotX = 0;
    let rotY = Math.PI / 2;
    let camDist = 8;
    let lastTouch = null, lastPinch = null;

    const getDist = (a,b) => Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
    const handleRot = (dx,dy,s=0.01) => { rotY += dx * s; rotX += dy * s; rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX)); };
    const handleZoom = (d,s=0.01) => { camDist += d * s; camDist = Math.max(3, Math.min(20, camDist)); };

    canvas.addEventListener('mousedown', e => { isRot = true; lastTouch = {x:e.clientX,y:e.clientY}; });
    window.addEventListener('mouseup', () => { isRot = false; lastTouch = null; });
    canvas.addEventListener('mousemove', e => {
      if (!isRot || !lastTouch) return;
      handleRot(e.clientX - lastTouch.x, e.clientY - lastTouch.y, 0.012);
      lastTouch = {x:e.clientX,y:e.clientY};
    });
    canvas.addEventListener('wheel', e => { e.preventDefault(); handleZoom(e.deltaY, 0.015); }, { passive:false });

    canvas.addEventListener('touchstart', e => {
      if (e.touches.length === 1) { isRot = true; lastTouch = {x:e.touches[0].clientX,y:e.touches[0].clientY}; lastPinch = null; }
      if (e.touches.length === 2) { isRot = false; lastTouch = null; lastPinch = getDist(e.touches[0], e.touches[1]); }
    }, { passive:false });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length === 1 && isRot && lastTouch) {
        handleRot(e.touches[0].clientX - lastTouch.x, e.touches[0].clientY - lastTouch.y, 0.015);
        lastTouch = {x:e.touches[0].clientX,y:e.touches[0].clientY};
      } else if (e.touches.length === 2 && lastPinch !== null) {
        const d = getDist(e.touches[0], e.touches[1]);
        handleZoom(lastPinch - d, 0.02);
        lastPinch = d;
      }
    }, { passive:false });
    canvas.addEventListener('touchend', e => {
      if (e.touches.length === 0) { isRot = false; lastTouch = null; lastPinch = null; }
      else if (e.touches.length === 1) { isRot = true; lastTouch = {x:e.touches[0].clientX,y:e.touches[0].clientY}; lastPinch = null; }
    }, { passive:false });

    const resize = () => {
      const w = canvas.clientWidth, h = Math.max(2, canvas.clientHeight);
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      renderer.setPixelRatio(dpr);
      renderer.setSize(w,h,false);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    };
    const ro = new ResizeObserver(resize);
    ro.observe(canvasContainer);
    resize();

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    const animate = () => {
      requestAnimationFrame(animate);
      camera.position.x = Math.cos(rotY) * Math.cos(rotX) * camDist;
      camera.position.y = Math.sin(rotX) * camDist;
      camera.position.z = Math.sin(rotY) * Math.cos(rotX) * camDist;
      camera.lookAt(0,0,0);

      for (let i=0;i<wordButtons.length;i++){
        const btn = wordButtons[i];
        if (!btn || !btn.userData) continue;
        const tm = btn.userData.textMesh;
        if (tm){
          tm.rotation.set(0,0,0);
          tm.scale.set(1,1,1);
        }
      }

      renderer.render(scene, camera);
    };
    animate();

    const handleClick = (clientX, clientY) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(wordButtons, true);
      if (intersects.length > 0){
        let obj = intersects[0].object;
        while (obj && !obj.onClick && obj.parent) obj = obj.parent;
        if (obj && obj.onClick) obj.onClick();
      }
    };
    canvas.addEventListener('click', e => handleClick(e.clientX, e.clientY));
    canvas.addEventListener('touchend', e => {
      if (e.changedTouches && e.changedTouches.length) handleClick(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    });
  }

  function createRoundedButtonGeometry(w=1.9,h=1.2,depth=BUTTON_DEPTH,r=0.16){
    const hw = w/2, hh = h/2, radius = Math.min(r, hw, hh);
    const shape = new THREE.Shape();
    shape.moveTo(-hw + radius, -hh);
    shape.lineTo(hw - radius, -hh);
    shape.quadraticCurveTo(hw, -hh, hw, -hh + radius);
    shape.lineTo(hw, hh - radius);
    shape.quadraticCurveTo(hw, hh, hw - radius, hh);
    shape.lineTo(-hw + radius, hh);
    shape.quadraticCurveTo(-hw, hh, -hw, hh - radius);
    shape.lineTo(-hw, -hh + radius);
    shape.quadraticCurveTo(-hw, -hh, -hw + radius, -hh);
    const extrude = new THREE.ExtrudeGeometry(shape, {
      depth,
      bevelEnabled: true,
      bevelThickness: 0.06,
      bevelSize: 0.06,
      bevelSegments: 6,
      curveSegments: 32
    });
    if (extrude.center) extrude.center();
    return extrude;
  }

  function makeFittedTextMesh(word, planeW=1.6, planeH=0.78){
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const baseW = 1024, baseH = 512;
    const tex = document.createElement('canvas');
    tex.width = Math.floor(baseW * dpr);
    tex.height = Math.floor(baseH * dpr);
    const ctx = tex.getContext('2d', { alpha:true });
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const pad = 28;
    const maxW = baseW - pad*2;
    const maxH = baseH - pad*2;

    let fs = 120;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    while (fs > 10){
      ctx.clearRect(0,0,baseW,baseH);
      ctx.font = `700 ${fs}px Inter, system-ui, sans-serif`;
      const w = ctx.measureText(word).width;
      const h = fs * 1.1;
      if (w <= maxW && h <= maxH) break;
      fs -= 2;
    }

    ctx.clearRect(0,0,baseW,baseH);
    ctx.shadowColor = 'rgba(110,231,245,0.14)';
    ctx.shadowBlur = 6;
    ctx.fillStyle = '#e8ebff';
    ctx.font = `700 ${fs}px Inter, system-ui, sans-serif`;
    ctx.fillText(word, baseW/2, baseH/2);

    const texture = new THREE.CanvasTexture(tex);
    texture.anisotropy = 4;
    texture.minFilter = THREE.LinearFilter;
    texture.needsUpdate = true;

    const mat = new THREE.MeshBasicMaterial({ map:texture, transparent:true, side:THREE.DoubleSide, depthTest:true, depthWrite:true });
    const geo = new THREE.PlaneGeometry(planeW, planeH);
    const mesh = new THREE.Mesh(geo, mat);
    mesh.renderOrder = 999;
    return { textMesh: mesh, fontSize: fs };
  }

  function createWordButton(word, position, index){
    const g = new THREE.Group();

    const geom = createRoundedButtonGeometry(1.9,1.2,BUTTON_DEPTH,0.18);
    const baseMat = new THREE.MeshPhysicalMaterial({
      color:0x161a36, metalness:0.05, roughness:0.6, clearcoat:0.6, clearcoatRoughness:0.4, opacity:0.98, transparent:true
    });
    const btn = new THREE.Mesh(geom, baseMat);
    btn.castShadow = true; btn.receiveShadow = true;
    g.add(btn);

    const rim = new THREE.Mesh(geom.clone(), new THREE.MeshStandardMaterial({
      color:0x1b2148, metalness:0.3, roughness:0.9, opacity:0.35, transparent:true
    }));
    rim.scale.set(1.02,1.02,1.02);
    g.add(rim);

    const { textMesh } = makeFittedTextMesh(word, 1.6, 0.78);
    textMesh.position.z = (BUTTON_DEPTH / 2) + TEXT_Z_OFFSET;
    textMesh.userData = { isText:true, word };
    g.add(textMesh);

    g.position.set(position.x, position.y, position.z);
    g.userData = { word, index, baseMaterial: baseMat, textMesh, buttonMesh: btn };

    g.onClick = () => speakSingle(word, g);
    return g;
  }

  function generatePositions(dimensions, size) {
      if (dimensions <= 3) {
          dimensions = 3;
      }

      const positions = [];
      const pointSpacing = 2.5; 
      const cubeMargin = 5.0; 

      const sideLength = Math.ceil(Math.pow(size, 1 / dimensions));

      const cubeWidth = (sideLength - 1) * pointSpacing;
      const gridSpacing = cubeWidth + cubeMargin; 

      for (let i = 0; i < size; i++) {
          const coords = [];
          let temp_i = i;
          for (let d = 0; d < dimensions; d++) {
              coords.push(temp_i % sideLength);
              temp_i = Math.floor(temp_i / sideLength);
          }

          const centerOffset = (sideLength - 1) / 2.0;

          const localX = (coords[0] - centerOffset) * pointSpacing;
          const localY = (coords[1] - centerOffset) * pointSpacing;
          const localZ = (coords[2] - centerOffset) * pointSpacing;

          let gridOffsetX = dimensions > 3 ? (coords[3] - centerOffset) * gridSpacing : 0;
          let gridOffsetY = dimensions > 4 ? (coords[4] - centerOffset) * gridSpacing : 0;
          let gridOffsetZ = dimensions > 5 ? (coords[5] - centerOffset) * gridSpacing : 0;

          if (dimensions > 6) {
              for (let d = 6; d < dimensions; d++) {
                  const factor = 0.5 / (d - 5); 
                  gridOffsetX += (coords[d] - centerOffset) * gridSpacing * factor * Math.cos(d);
                  gridOffsetY += (coords[d] - centerOffset) * gridSpacing * factor * Math.sin(d);
              }
          }

          positions.push({
              x: localX + gridOffsetX,
              y: localY + gridOffsetY,
              z: localZ + gridOffsetZ,
          });
      }
      return positions;
  }

  function render3DVisualization(words, numDimensions){
    initThreeJS();
    wordButtons.forEach(b => scene.remove(b));
    wordButtons = [];

    let positions = generatePositions(numDimensions, words.length);
    dimensionInfo.textContent = (numDimensions === 3) ? `3D Kubus (${words.length} varianten)` : `${numDimensions}D Hyperkubus (${words.length} varianten)`;

    words.forEach((w,i) => {
      if (i < positions.length){
        const btn = createWordButton(w, positions[i], i);
        scene.add(btn);
        wordButtons.push(btn);
      }
    });
  }

  function fitText(el){
    let s = 32; el.style.fontSize = s + 'px'; el.style.whiteSpace='nowrap';
    while ((el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) && s > 10){ s -= 1; el.style.fontSize = s + 'px'; }
  }

  function renderGrid(words, N){
    if (N === 3 || N >= 4){
      grid.style.display = 'none';
      canvasContainer.style.display = 'block';
      if (!scene) initThreeJS();
      render3DVisualization(words, N);
    } else {
      canvasContainer.style.display = 'none';
      grid.style.display = 'grid';
      grid.innerHTML = '';
      grid.style.gridTemplateColumns = `repeat(${N}, 1fr)`;
      words.forEach((w,i) => {
        const cell = document.createElement('div');
        cell.className = 'cell'; cell.id = 'w'+i; cell.textContent = w;
        cell.addEventListener('click', () => speakSingle(w, cell));
        grid.appendChild(cell);
        fitText(cell);
      });
    }
  }

  let cachedVoice = null;
  const pickDutchVoice = () => {
    const list = speechSynthesis.getVoices() || [];
    const byLang = list.find(v => /^nl(-|$)/i.test(v.lang));
    const byName = list.find(v => /dutch|nederlands/i.test(v.name));
    cachedVoice = byLang || byName || list.find(v => /^nl/i.test(v.lang)) || list[0] || null;
    return cachedVoice;
  };
  speechSynthesis.onvoiceschanged = pickDutchVoice;

  const findVowelGroups = (word) => {
    const lower = word.toLowerCase();
    const matches = []; let i=0;
    while (i < lower.length){
      let found = null;
      for (const vg of vowelGroups) if (lower.startsWith(vg, i)) { found = vg; break; }
      if (found){ matches.push({ group: found, index: i, length: found.length }); i += found.length; }
      else i++;
    }
    return matches;
  };

  const analyzeWord = (raw) => {
    const word = (raw||'').trim();
    if (!/^[A-Za-z]+( [A-Za-z]+)*$/.test(word)) return { ok:false };
    const groups = findVowelGroups(word);
    const uniqueGroups = [...new Set(groups.map(g=>g.group))];
    if (uniqueGroups.length < 2) return { ok:false };
    return { ok:true, word, groups, uniqueGroups };
  };

  const generateAllCombinations = (uniqueGroups, numPositions) => {
    const combos=[]; const total = Math.pow(uniqueGroups.length, numPositions);
    for (let i=0;i<total;i++){
      const combo=[]; let temp=i;
      for (let pos=0; pos<numPositions; pos++){ combo.push(uniqueGroups[temp % uniqueGroups.length]); temp = Math.floor(temp / uniqueGroups.length); }
      combos.push(combo);
    }
    return combos;
  };

  const buildVariants = (word, groups, uniqueGroups) => {
    const numVowelGroups = groups.length;
    const combos = generateAllCombinations(uniqueGroups, numVowelGroups);
    const variants = [];
    for (const combo of combos){
      let res = '', pos = 0;
      for (let i=0;i<groups.length;i++){
        const group = groups[i];
        res += word.slice(pos, group.index) + combo[i];
        pos = group.index + group.length;
      }
      res += word.slice(pos);
      variants.push(res);
    }
    return variants;
  };

  const speakWord = (text, onend) => {
    const u = new SpeechSynthesisUtterance(text);
    u.rate = 0.95; u.pitch = 1.0; u.volume = 1.0; u.lang = 'nl-NL';
    const v = cachedVoice || pickDutchVoice();
    if (v) u.voice = v;
    u.onend = onend;
    speechSynthesis.speak(u);
  };

  const clearActive = () => {
    document.querySelectorAll('.cell.active').forEach(el => el.classList.remove('active'));
    wordButtons.forEach(button => {
      if (button.userData && button.userData.baseMaterial) {
        button.children[0].material = button.userData.baseMaterial;
      }
    });
  };

  const stopSpeech = (silent=false) => { speaking=false; speechSynthesis.cancel(); if(!silent) clearActive(); };

  const playSequence = (words) => {
    stopSpeech(true); speaking = true;
    const step = (idx) => {
      if (!speaking || idx >= words.length) { speaking=false; clearActive(); return; }
      clearActive();
      if (canvasContainer.style.display !== 'none'){
        if (wordButtons[idx]){
          const button = wordButtons[idx];
          const highlightMaterial = new THREE.MeshPhongMaterial({ color:0x9b8cff, transparent:true, opacity:0.95, emissive:0x6ee7f5, emissiveIntensity:0.35 });
          button.children[0].material = highlightMaterial;
        }
      } else {
        const cell = document.getElementById('w'+idx); if (cell) cell.classList.add('active');
      }
      speakWord(words[idx], () => step(idx+1));
    };
    step(0);
  };

  const speakSingle = (word, element) => {
    stopSpeech(true); clearActive();
    if (element.userData && element.userData.baseMaterial){
      const highlightMaterial = new THREE.MeshPhongMaterial({ color:0x9b8cff, transparent:true, opacity:0.95, emissive:0x6ee7f5, emissiveIntensity:0.4 });
      const original = element.userData.baseMaterial;
      element.children[0].material = highlightMaterial;
      speakWord(word, () => { if (element && element.children && element.children[0]) element.children[0].material = original; });
    } else {
      element.classList.add('active');
      speakWord(word, () => element.classList.remove('active'));
    }
  };

  const showError = () => {
    stopSpeech(true);
    if (!modal.open) modal.showModal();
    const u = new SpeechSynthesisUtterance('Neehee');
    const v = cachedVoice || pickDutchVoice();
    if (v) u.voice = v;
    u.lang = 'nl-NL'; u.rate = 1; u.pitch = 0.9;
    speechSynthesis.speak(u);
  };

  closeModal.addEventListener('click', () => { if (modal.open) modal.close(); input.focus(); input.select(); });

  form.addEventListener('submit', (e) => {
    e.preventDefault();
    const check = analyzeWord(input.value);
    if (!check.ok) { showError(); return; }

    outputCard.style.display = 'block';
    
    const variants = buildVariants(check.word, check.groups, check.uniqueGroups);
    renderGrid(variants, check.uniqueGroups.length);
    playSequence(variants);
  });

  btnSpeak.addEventListener('click', () => {
    let words = [];
    if (canvasContainer.style.display !== 'none') words = wordButtons.map(b => b.userData.word);
    else words = [...grid.querySelectorAll('.cell')].map(x => x.textContent);
    if (words.length) playSequence(words);
  });

  btnStop.addEventListener('click', () => stopSpeech());

  input.setAttribute('autofocus','true');
})();
</script>
</body>
</html>
