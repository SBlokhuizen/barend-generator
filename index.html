<!doctype html>
<html lang="nl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Barend Generator</title>
    <meta name="description" content="Cree√´r je eigen Barendogram!" />
    <link rel="icon" type="image/jpeg" href="barend_icon.jpeg" />
    <meta property="og:title" content="Barend Generator" />
    <meta property="og:description" content="Cree√´r je eigen Barendogram!" />
    <meta
      property="og:image"
      content="https://sblokhuizen.github.io/barend/barend.jpeg"
    />
    <meta property="og:url" content="https://sblokhuizen.github.io/barend/" />
    <meta property="og:type" content="website" />
    <style>
      :root {
        --bg: #0f1226;
        --card: #161a36;
        --accent: #6ee7f5;
        --accent-2: #9b8cff;
        --accent-3: #4ade80;
        --muted: #9aa3b2;
        --text: #e8ebff;
        --danger: #ff4d6d;
        --shadow:
          0 20px 60px rgba(0, 0, 0, 0.45), 0 2px 10px rgba(0, 0, 0, 0.25);
        --radius: 16px;
        --morph-y-offset: -72.5%;
      }
      @media (min-width: 769px) {
        :root {
          --morph-y-offset: -77.5%;
        }
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      body {
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background:
          radial-gradient(
            1200px 600px at 10% -10%,
            #1a1f46 0%,
            transparent 60%
          ),
          radial-gradient(900px 500px at 110% 10%, #1a2b4a 0%, transparent 60%),
          linear-gradient(180deg, #0b0e1d 0%, #0f1226 60%, #0b0e1d 100%);
        color: var(--text);
        font:
          16px/1.5 "Inter",
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      .wrap {
        width: min(880px, calc(100% - 48px));
        max-width: 880px;
        display: grid;
        gap: 22px;
        align-content: center;
        margin: 0;
      }
      .title-link {
        text-decoration: none;
        color: inherit;
        cursor: pointer;
      }
      .card {
        background:
          linear-gradient(
              135deg,
              rgba(110, 231, 245, 0.08),
              rgba(155, 140, 255, 0.06)
            )
            padding-box,
          linear-gradient(
              135deg,
              rgba(110, 231, 245, 0.35),
              rgba(155, 140, 255, 0.35)
            )
            border-box;
        border: 1px solid transparent;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 18px;
        backdrop-filter: blur(10px);
      }
      .title {
        font-weight: 800;
        letter-spacing: 0.3px;
        font-size: clamp(36px, 2.4vw, 30px);
        margin: 0 0 8px 0;
        display: flex;
        align-items: center;
        background: var(--accent);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }
      .title-text {
        background: none;
        -webkit-background-clip: inherit;
        background-clip: inherit;
        color: inherit;
      }
      .morphing-letter {
        position: relative;
        display: inline-block;
        width: 0.6em;
        overflow: hidden;
      }
      .letter-container {
        position: relative;
        display: inline-block;
      }
      .letter-a,
      .letter-e {
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateY(var(--morph-y-offset));
        -webkit-background-clip: text;
        background-clip: text;
        color: var(--accent);
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .letter-a {
        opacity: 1;
        transform: translateY(var(--morph-y-offset)) scale(1);
      }
      .letter-e {
        opacity: 0;
        transform: translateY(var(--morph-y-offset)) scale(0.3);
      }
      .morph-state-barend .pos1 .letter-a {
        opacity: 1;
        transform: translateY(var(--morph-y-offset)) scale(1);
      }
      .morph-state-barend .pos1 .letter-e {
        opacity: 0;
        transform: translateY(var(--morph-y-offset)) scale(0.3);
      }
      .morph-state-barend .pos2 .letter-a {
        opacity: 0;
        transform: translateY(var(--morph-y-offset)) scale(0.3);
      }
      .morph-state-barend .pos2 .letter-e {
        opacity: 1;
        transform: translateY(var(--morph-y-offset)) scale(1);
      }
      .morph-state-barand .pos1 .letter-a {
        opacity: 1;
        transform: translateY(var(--morph-y-offset)) scale(1);
      }
      .morph-state-barand .pos1 .letter-e {
        opacity: 0;
        transform: translateY(var(--morph-y-offset)) scale(0.3);
      }
      .morph-state-barand .pos2 .letter-a {
        opacity: 1;
        transform: translateY(var(--morph-y-offset)) scale(1);
      }
      .morph-state-barand .pos2 .letter-e {
        opacity: 0;
        transform: translateY(var(--morph-y-offset)) scale(0.3);
      }
      .morph-state-berand .pos1 .letter-a {
        opacity: 0;
        transform: translateY(var(--morph-y-offset)) scale(0.3);
      }
      .morph-state-berand .pos1 .letter-e {
        opacity: 1;
        transform: translateY(var(--morph-y-offset)) scale(1);
      }
      .morph-state-berand .pos2 .letter-a {
        opacity: 1;
        transform: translateY(var(--morph-y-offset)) scale(1);
      }
      .morph-state-berand .pos2 .letter-e {
        opacity: 0;
        transform: translateY(var(--morph-y-offset)) scale(0.3);
      }
      .morph-state-berend .pos1 .letter-a {
        opacity: 0;
        transform: translateY(var(--morph-y-offset)) scale(0.3);
      }
      .morph-state-berend .pos1 .letter-e {
        opacity: 1;
        transform: translateY(var(--morph-y-offset)) scale(1);
      }
      .morph-state-berend .pos2 .letter-a {
        opacity: 0;
        transform: translateY(var(--morph-y-offset)) scale(0.3);
      }
      .morph-state-berend .pos2 .letter-e {
        opacity: 1;
        transform: translateY(var(--morph-y-offset)) scale(1);
      }
      form {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 8px;
      }
      input[type="text"] {
        flex: 1 1 320px;
        min-width: 0;
        padding: 12px 14px;
        font-size: 18px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: #0e1230;
        color: var(--text);
        outline: none;
        font-weight: 600;
      }
      input[type="text"]:focus {
        border-color: var(--accent);
        box-shadow: 0 0 0 6px rgba(110, 231, 245, 0.08);
      }
      .btn {
        appearance: none;
        border: 0;
        cursor: pointer;
        padding: 20px 32px;
        border-radius: 12px;
        font-weight: 700;
        letter-spacing: 0.3px;
        transition:
          transform 0.06s ease,
          box-shadow 0.18s ease,
          opacity 0.18s ease;
        white-space: nowrap;
        flex: 0 0 auto;
        font-size: 18px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .btn:disabled {
        cursor: not-allowed;
        opacity: 0.5;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn.primary {
        color: #02131a;
        background: linear-gradient(135deg, var(--accent), #6fd4ff);
        box-shadow: 0 10px 30px rgba(110, 231, 245, 0.22);
      }
      .btn.ghost {
        color: #dbe7ff;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.12);
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(8px);
      }
      .card .btn.ghost {
        -webkit-backdrop-filter: none;
        backdrop-filter: none;
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(255, 255, 255, 0.16);
      }
      .btn.ghost svg {
        vertical-align: middle;
      }
      .btn.stop {
        color: #33000b;
        background: linear-gradient(135deg, #ff97aa, var(--danger));
        box-shadow: 0 10px 30px rgba(255, 77, 109, 0.12);
      }
      .top-left-controls {
        position: fixed;
        top: 24px;
        left: 24px;
        display: block;
        z-index: 100;
      }
      #menu-toggle {
        position: relative;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
      #menu-toggle svg {
        transition: opacity 0.2s ease;
      }

      .top-left-controls.menu-open #menu-toggle {
        transform: rotate(180deg);
        border-color: var(--accent);
      }
      .menu-items {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 8px;
        pointer-events: none;
      }
      .menu-items .btn {
        opacity: 0;
        transform: translateY(-10px);
        transition:
          opacity 0.2s ease,
          transform 0.2s ease;
      }
      .top-left-controls.menu-open .menu-items {
        pointer-events: auto;
      }
      .top-left-controls.menu-open .menu-items .btn {
        opacity: 1;
        transform: translateY(0);
      }
      .top-left-controls.menu-open .menu-items .btn:nth-child(1) {
        transition-delay: 0.04s;
      }
      .top-left-controls.menu-open .menu-items .btn:nth-child(2) {
        transition-delay: 0.08s;
      }
      .top-left-controls.menu-open .menu-items .btn:nth-child(3) {
        transition-delay: 0.12s;
      }
      .top-left-controls.menu-open .menu-items .btn:nth-child(4) {
        transition-delay: 0.16s;
      }
      .top-left-controls.menu-open .menu-items .btn:nth-child(5) {
        transition-delay: 0.2s;
      }
      .grid {
        margin-top: 12px;
        display: grid;
        gap: 14px;
      }
      #grid {
        max-height: clamp(320px, 60vh, 600px);
        overflow-y: auto;
        padding-right: 8px;
        scrollbar-width: thin;
        scrollbar-color: rgba(255, 255, 255, 0.2) rgba(255, 255, 255, 0.05);
      }
      #grid::-webkit-scrollbar {
        width: 8px;
      }
      #grid::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
      }
      #grid::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
      }
      #grid::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
      }
      #info-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 8px;
      }
      #combo-count {
        font-weight: 600;
        color: var(--muted);
        white-space: nowrap;
      }
      #pagination-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      #page-indicator {
        font-weight: 600;
        color: var(--muted);
        cursor: pointer;
        padding: 0 8px;
        white-space: nowrap;
      }
      .cell {
        border-radius: 14px;
        padding: 16px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0.02)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        text-align: center;
        font-weight: 900;
        font-size: clamp(18px, 3.2vw, 32px);
        letter-spacing: 0.6px;
        position: relative;
        overflow: hidden;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1.1;
        white-space: nowrap;
        transition:
          border-color 0.15s ease,
          background-color 0.15s ease,
          box-shadow 0.15s ease;
      }
      .cell::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(
          600px 180px at var(--x, 50%) var(--y, 50%),
          rgba(110, 231, 245, 0.12),
          transparent 60%
        );
        opacity: 0;
        transition: opacity 0.25s ease;
      }
      .cell:hover::after {
        opacity: 1;
      }
      .cell.active {
        background: linear-gradient(
          180deg,
          rgba(155, 140, 255, 0.18),
          rgba(110, 231, 245, 0.12)
        );
        border-color: rgba(110, 231, 245, 0.65);
        box-shadow:
          inset 0 0 0 6px rgba(110, 231, 245, 0.08),
          inset 0 0 40px rgba(110, 231, 245, 0.06);
      }
      .cell.valid {
        background: linear-gradient(
          180deg,
          rgba(74, 222, 128, 0.18),
          rgba(74, 222, 128, 0.12)
        );
        border-color: rgba(74, 222, 128, 0.65);
        box-shadow:
          inset 0 0 0 6px rgba(74, 222, 128, 0.08),
          inset 0 0 40px rgba(74, 222, 128, 0.06);
      }
      .cell.invalid {
        background: linear-gradient(
          180deg,
          rgba(255, 77, 109, 0.18),
          rgba(255, 77, 109, 0.12)
        );
        border-color: rgba(255, 77, 109, 0.65);
        box-shadow:
          inset 0 0 0 6px rgba(255, 77, 109, 0.08),
          inset 0 0 40px rgba(255, 77, 109, 0.06);
      }
      .cell.shake {
        animation: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
      }
      .cell.bounce {
        animation: bounce 0.5s ease both;
      }
      @keyframes shake {
        10%,
        90% {
          transform: translate3d(-1px, 0, 0);
        }
        20%,
        80% {
          transform: translate3d(2px, 0, 0);
        }
        30%,
        50%,
        70% {
          transform: translate3d(-4px, 0, 0);
        }
        40%,
        60% {
          transform: translate3d(4px, 0, 0);
        }
      }
      @keyframes bounce {
        0%,
        20%,
        50%,
        80%,
        100% {
          transform: translateY(0);
        }
        40% {
          transform: translateY(-15px);
        }
        60% {
          transform: translateY(-7px);
        }
      }
      #canvas-container {
        height: clamp(320px, 60vh, 600px);
        position: relative;
        border-radius: 16px;
        overflow: hidden;
        background: linear-gradient(
          135deg,
          rgba(0, 0, 0, 0.25),
          rgba(0, 0, 0, 0.08)
        );
      }
      #three-canvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
        background: transparent;
      }
      .canvas-overlay {
        position: absolute;
        top: 12px;
        left: 12px;
        right: 12px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        pointer-events: none;
        z-index: 10;
      }
      .canvas-controls {
        background: rgba(0, 0, 0, 0.68);
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 12px;
        color: #c4cbe0;
        pointer-events: auto;
        border: 1px solid rgba(255, 255, 255, 0.06);
        backdrop-filter: blur(6px);
      }
      .desktop-hint {
        display: block;
      }
      .mobile-hint {
        display: none;
      }
      @media (max-width: 768px) {
        .desktop-hint {
          display: none;
        }
        .mobile-hint {
          display: block;
        }
      }
      .dimension-info {
        background: rgba(110, 231, 245, 0.08);
        border: 1px solid rgba(110, 231, 245, 0.22);
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 13px;
        font-weight: 600;
        color: #dcecff;
        backdrop-filter: blur(4px);
      }
      dialog::backdrop {
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.45),
          rgba(0, 0, 0, 0.65)
        );
      }
      dialog {
        border: 0;
        border-radius: 16px;
        padding: 0;
        overflow: hidden;
        background: linear-gradient(180deg, #1b1f45, #131736);
        color: var(--text);
        box-shadow: var(--shadow);
        max-width: 500px;
        width: calc(100% - 32px);
      }
      .modal-head {
        padding: 14px 16px;
        background: linear-gradient(
          90deg,
          rgba(255, 77, 109, 0.18),
          rgba(110, 231, 245, 0.06)
        );
        display: flex;
        align-items: center;
      }
      .modal-title {
        font-size: 18px;
        font-weight: 900;
        color: #fff;
      }
      .modal-body {
        padding: 14px 16px;
        color: #dfe5ff;
        max-height: 60vh;
        overflow-y: auto;
      }
      .modal-actions {
        padding: 12px 16px;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        background: #0e1230;
      }
      .kbd {
        font:
          600 12px ui-monospace,
          Menlo,
          Monaco,
          monospace;
        background: #0e1230;
        border: 1px solid rgba(255, 255, 255, 0.12);
        padding: 2px 6px;
        border-radius: 6px;
        color: #b8c0de;
      }
      .option-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        padding: 12px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }
      .option-row:last-child {
        border-bottom: none;
      }
      .option-row label,
      .option-row > span {
        flex-grow: 1;
      }
      .option-row input[type="range"] {
        flex: 0 1 140px;
      }
      .slider-value {
        font-weight: 600;
        min-width: 32px;
        text-align: right;
        color: var(--muted);
      }
      .toggle-switch {
        appearance: none;
        width: 40px;
        height: 22px;
        background: #333863;
        border-radius: 22px;
        position: relative;
        cursor: pointer;
        transition: background-color 0.2s ease;
        flex-shrink: 0;
      }
      .toggle-switch::before {
        content: "";
        position: absolute;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: white;
        top: 3px;
        left: 3px;
        transition: transform 0.2s ease;
      }
      .toggle-switch:checked {
        background: var(--accent-3);
      }
      .toggle-switch:checked::before {
        transform: translateX(18px);
      }
      .option-group {
        padding: 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }
      .option-group-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
      }
      .option-group-header span {
        flex-grow: 1;
      }
      .vowel-controls {
        display: flex;
        gap: 8px;
      }
      .btn-tiny {
        appearance: none;
        border: 0;
        cursor: pointer;
        padding: 4px 10px;
        border-radius: 8px;
        font-weight: 600;
        font-size: 12px;
        background: rgba(255, 255, 255, 0.06);
        color: #c4cbe0;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: background 0.15s ease;
      }
      .btn-tiny:hover {
        background: rgba(255, 255, 255, 0.12);
      }
      .vowel-group-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 12px 16px;
      }
      .vowel-group-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-family: ui-monospace, Menlo, Monaco, monospace;
        font-weight: 600;
        color: var(--muted);
      }
      .vowel-group-item label {
        flex-grow: 1;
      }
      details > summary {
        list-style: none;
        cursor: pointer;
        position: relative;
      }
      details > summary::-webkit-details-marker {
        display: none;
      }
      details > summary.option-row {
        transition: background-color 0.15s ease;
        padding-left: 10px;
        padding-right: 10px;
        margin: 0 -10px;
        border-radius: 8px;
      }
      details > summary.option-row:hover {
        background-color: rgba(255, 255, 255, 0.05);
      }
      details .option-row::after {
        content: "‚Ä∫";
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%) rotate(0deg);
        font-size: 24px;
        font-weight: 300;
        line-height: 1;
        color: var(--muted);
        transition: transform 0.2s ease-in-out;
      }
      details[open] > .option-row::after {
        transform: translateY(-50%) rotate(90deg);
      }
      .collapsible-content {
        padding: 12px 16px 16px 16px;
        background: rgba(0, 0, 0, 0.1);
      }
      #barendroom-overlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: linear-gradient(to top, #6dd5ed, #2193b0);
        opacity: 0;
        animation: fadeIn 1s forwards;
        overflow: hidden;
        cursor: pointer;
      }
      .barendroom-popup {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.5);
        background: rgba(255, 255, 255, 0.9);
        color: #2193b0;
        border-radius: 24px;
        padding: 30px 50px;
        text-align: center;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        animation: popUp 1s 0.5s forwards
          cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }
      .barendroom-popup h2 {
        font-size: 48px;
        margin: 0;
      }
      .barendroom-popup p {
        font-size: 20px;
        margin: 10px 0 0;
      }
      .cloud {
        position: absolute;
        background: radial-gradient(
          circle,
          white 60%,
          rgba(255, 255, 255, 0) 100%
        );
        border-radius: 50%;
        opacity: 0.6;
        animation: moveCloud 20s linear infinite;
      }
      .cloud.c1 {
        width: 200px;
        height: 60px;
        top: 10%;
        left: -250px;
      }
      .cloud.c2 {
        width: 300px;
        height: 90px;
        top: 25%;
        left: -350px;
        animation-duration: 25s;
        animation-delay: -5s;
      }
      .cloud.c3 {
        width: 150px;
        height: 45px;
        top: 60%;
        left: -200px;
        animation-duration: 18s;
        animation-delay: -10s;
      }
      .confetti {
        position: absolute;
        width: 10px;
        height: 20px;
        background: #f00;
        opacity: 0.8;
        animation: fall 5s linear infinite;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      @keyframes popUp {
        from {
          transform: translate(-50%, -50%) scale(0.5);
        }
        to {
          transform: translate(-50%, -50%) scale(1);
        }
      }
      @keyframes moveCloud {
        from {
          transform: translateX(0);
        }
        to {
          transform: translateX(calc(100vw + 400px));
        }
      }
      @keyframes fall {
        from {
          transform: translateY(-10vh) rotate(0deg);
          opacity: 1;
        }
        to {
          transform: translateY(110vh) rotate(720deg);
          opacity: 0;
        }
      }
      #barendroom-2d-overlay {
        position: fixed;
        inset: 0;
        z-index: 10000;
        background-color: var(--bg);
        overflow: hidden;
      }
      #trace-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .bouncing-cell {
        position: fixed;
        border-radius: 14px;
        padding: 16px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.04),
          rgba(255, 255, 255, 0.02)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        text-align: center;
        font-weight: 900;
        font-size: clamp(18px, 3.2vw, 32px);
        letter-spacing: 0.6px;
        line-height: 1.1;
        white-space: nowrap;
        will-change: transform;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        color: var(--text);
      }
      .barendroom-congrats-popup {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(1);
        background: var(--card);
        border-radius: var(--radius);
        padding: 24px 32px;
        text-align: center;
        box-shadow: var(--shadow);
        z-index: 10001;
        border: 1px solid rgba(110, 231, 245, 0.35);
        animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        transition:
          transform 0.3s ease,
          opacity 0.3s ease;
      }
      .barendroom-congrats-popup h2 {
        font-size: 32px;
        margin: 0 0 12px 0;
        background: var(--accent);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }
      .barendroom-congrats-popup p {
        font-size: 18px;
        margin-bottom: 24px;
        color: var(--muted);
      }
      .barendroom-popup-actions {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
      }
      .barendroom-popup-actions .btn {
        padding: 10px 20px;
        font-size: 14px;
      }
      #leaderboard-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 12px;
      }
      #leaderboard-table th,
      #leaderboard-table td {
        padding: 10px;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      #leaderboard-table th {
        font-weight: 700;
        color: var(--muted);
        font-size: 14px;
      }
      #leaderboard-table td {
        font-size: 15px;
      }
      .revealed-word-container {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .revealed-word-container span {
        font-weight: 700;
        color: var(--accent);
      }
      .clickable-barendroom {
        cursor: pointer;
        font-weight: 700;
        color: var(--accent);
        transition: text-decoration 0.2s ease;
      }
      .clickable-barendroom:hover {
        text-decoration: underline;
      }
      .def-link {
        color: var(--accent);
        font-weight: 600;
        cursor: pointer;
        text-decoration: none;
        border-bottom: 1px dotted var(--accent);
      }
      .def-link:hover {
        text-decoration: none;
        border-bottom: 1px solid var(--accent);
      }
      @keyframes highlight-def {
        from {
          background-color: rgba(110, 231, 245, 0.2);
        }
        to {
          background-color: transparent;
        }
      }
      .highlight-def {
        animation: highlight-def 1.5s ease-out;
        border-radius: 4px;
      }

      @media (max-width: 680px) {
        .wrap {
          width: calc(100% - 24px);
        }
        form {
          gap: 8px;
        }
        input[type="text"] {
          flex-basis: 100%;
        }
        .btn {
          padding: 12px 16px;
          font-size: 16px;
        }
        #info-bar {
          justify-content: center;
        }
        .form-actions {
          display: flex;
          width: 100%;
          gap: 8px;
        }
        .form-actions .btn {
          flex-grow: 1;
          flex-basis: 0;
        }
        .form-actions #options-btn {
          flex-grow: 0;
        }
        .top-left-controls {
          top: 16px;
          left: 16px;
        }
      }
    </style>
  </head>
  <body>
    <div class="top-left-controls">
      <button
        type="button"
        class="btn ghost"
        id="menu-toggle"
        aria-label="Menu"
        aria-expanded="false"
        aria-controls="menu-items-wrapper"
      >
        <svg
          id="menu-icon"
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2.5"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <line class="top" x1="4" y1="6" x2="20" y2="6"></line>
          <line class="middle" x1="4" y1="12" x2="20" y2="12"></line>
          <line class="bottom" x1="4" y1="18" x2="20" y2="18"></line>
        </svg>
      </button>
      <div class="menu-items" id="menu-items-wrapper">
        <button
          type="button"
          class="btn ghost"
          id="options-btn"
          aria-label="Instellingen"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="currentColor"
          >
            <path
              d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24-.42-.12-.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"
            />
          </svg>
        </button>
        <button
          type="button"
          class="btn ghost"
          id="leaderboard-btn"
          aria-label="Leaderboard"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="currentColor"
          >
            <path
              d="M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.98 2.63 3.61 2.96V19H7v2h10v-2h-4v-3.1c1.63-.33 2.98-1.46 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2zM5 8V7h2v3.82C5.84 10.4 5 9.3 5 8zm7 6c-1.65 0-3-1.35-3-3V5h6v6c0 1.65-1.35 3-3 3zm7-6c0 1.3-.84 2.4-2 2.82V7h2v1z"
            />
          </svg>
        </button>
        <button
          type="button"
          class="btn ghost"
          id="definitions-btn"
          aria-label="Woordenboek"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path
              d="M3 4c1.1-.5 2.4-.9 4-.9 1.7 0 3.3.4 5 1.3 1.7-.9 3.3-1.3 5-1.3 1.6 0 2.9.4 4 .9v15c-1.1-.5-2.4-.9-4-.9-1.7 0-3.3.4-5 1.3-1.7-.9-3.3-1.3-5-1.3-1.6 0-2.9.4-4 .9V4z"
            />
            <line x1="12" y1="5" x2="12" y2="20" />
          </svg>
        </button>
        <button
          type="button"
          class="btn ghost"
          id="help-btn"
          aria-label="Uitleg"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="currentColor"
          >
            <path
              d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"
            />
          </svg>
        </button>
        <button
          type="button"
          class="btn ghost"
          id="share-btn"
          aria-label="Delen"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="currentColor"
          >
            <path
              d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"
            />
          </svg>
        </button>
      </div>
    </div>

    <div class="wrap" role="main">
      <a href="." class="title-link" aria-label="Home">
        <h1 id="title" class="title">
          <span class="title-text">B</span>
          <div class="morphing-letter pos1">
            <div class="letter-container">
              <span class="letter-a">a</span>
              <span class="letter-e">e</span>
            </div>
          </div>
          <span class="title-text">r</span>
          <div class="morphing-letter pos2">
            <div class="letter-container">
              <span class="letter-a">a</span>
              <span class="letter-e">e</span>
            </div>
          </div>
          <span class="title-text">nd Generator</span>
        </h1>
      </a>

      <header class="card" aria-labelledby="title">
        <form id="scramble-form" autocomplete="off" novalidate>
          <input
            id="word"
            name="word"
            type="text"
            spellcheck="false"
            placeholder="bijv. Barend"
            maxlength="48"
          />
          <div class="form-actions">
            <button type="submit" class="btn primary" id="generate">
              Genereren
            </button>
            <button
              type="button"
              class="btn ghost"
              id="random-word-btn"
              title="Genereer met een willekeurig woord"
            >
              Verras me
            </button>
            <button type="button" class="btn stop" id="stop">Stop</button>
          </div>
        </form>
      </header>
      <section
        id="output-card"
        class="card"
        aria-live="polite"
        style="display: none"
      >
        <div id="info-bar">
          <div id="combo-count"></div>
          <div id="pagination-controls" style="display: none">
            <span id="page-indicator"></span>
            <button
              type="button"
              class="btn ghost"
              id="randomize-btn"
              aria-label="Willekeurige volgorde"
              title="Willekeurige volgorde"
              style="display: none; padding: 10px"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <polyline points="16 3 21 3 21 8"></polyline>
                <line x1="4" y1="20" x2="21" y2="3"></line>
                <polyline points="21 16 21 21 16 21"></polyline>
                <line x1="15" y1="15" x2="21" y2="21"></line>
                <line x1="4" y1="4" x2="9" y2="9"></line>
              </svg>
            </button>
            <button
              type="button"
              class="btn ghost"
              id="prev-page"
              aria-label="Vorige pagina"
            >
              &lt;
            </button>
            <button
              type="button"
              class="btn ghost"
              id="next-page"
              aria-label="Volgende pagina"
            >
              &gt;
            </button>
          </div>
        </div>
        <div id="grid" class="grid" aria-hidden="false"></div>
        <div id="canvas-container" style="display: none">
          <canvas
            id="three-canvas"
            role="img"
            aria-label="3D knoppen canvas"
          ></canvas>
          <div class="canvas-overlay">
            <div class="canvas-controls">
              <span class="desktop-hint"
                >Sleep = roteren ‚Ä¢ Scroll/knijp = zoomen</span
              >
              <span class="mobile-hint">Sleep = roteren ‚Ä¢ Knijp = zoomen</span>
            </div>
            <div class="dimension-info" id="dimension-info"></div>
          </div>
        </div>
      </section>
    </div>
    <dialog
      id="modal"
      aria-modal="true"
      role="dialog"
      aria-labelledby="error-modal-title"
    >
      <div class="modal-head">
        <div id="error-modal-title" class="modal-title">NEEHEE</div>
      </div>
      <div class="modal-body">
        <p>
          Het woord moet minstens twee verschillende klinkergroepen bevatten.
          Geldige groepen: <span class="kbd" id="valid-vowels-list"></span>.
        </p>
      </div>
      <div class="modal-actions">
        <button class="btn primary" id="close-modal">OK</button>
      </div>
    </dialog>
    <dialog
      id="warning-modal"
      aria-modal="true"
      role="dialog"
      aria-labelledby="warning-modal-title"
    >
      <div class="modal-head">
        <div id="warning-modal-title" class="modal-title">Waarschuwing</div>
      </div>
      <div class="modal-body">
        <p id="warning-modal-text"></p>
      </div>
      <div class="modal-actions">
        <button class="btn ghost" id="confirm-cancel">Annuleren</button>
        <button class="btn primary" id="confirm-proceed">Doorgaan</button>
      </div>
    </dialog>
    <dialog
      id="options-modal"
      aria-modal="true"
      role="dialog"
      aria-labelledby="options-modal-title"
    >
      <div class="modal-head">
        <div id="options-modal-title" class="modal-title">Instellingen</div>
      </div>
      <div class="modal-body">
        <div class="option-row">
          <label for="enable-3d" title="Toon de combinaties in een 3D-ruimte."
            >3D weergave inschakelen</label
          >
          <input type="checkbox" id="enable-3d" class="toggle-switch" />
        </div>
        <div class="option-row">
          <label
            for="enable-validation-highlight"
            title="Controleert of de gegenereerde woorden in het woordenboek bestaan."
            >Barendroom Validatie</label
          >
          <input
            type="checkbox"
            id="enable-validation-highlight"
            class="toggle-switch"
          />
        </div>
        <div class="option-row">
          <label
            for="language-select"
            title="Selecteer de taal en stem voor het uitspreken van de woorden."
            >Spraaktaal</label
          >
          <select
            id="language-select"
            style="
              background: #0e1230;
              color: var(--text);
              border: 1px solid rgba(255, 255, 255, 0.12);
              border-radius: 6px;
              padding: 4px 8px;
              flex: 0 1 172px;
            "
          ></select>
        </div>
        <details id="vowel-options-details" class="option-group">
          <summary class="option-row">
            <span
              title="Kies welke klinkergroepen gebruikt mogen worden om variaties te genereren."
              >Toegestane Klinkergroepen</span
            >
          </summary>
          <div class="collapsible-content">
            <div class="option-group-header">
              <span></span>
              <div class="vowel-controls">
                <button type="button" class="btn-tiny" id="vowels-all">
                  Alles
                </button>
                <button type="button" class="btn-tiny" id="vowels-none">
                  Geen
                </button>
              </div>
            </div>
            <div id="vowel-group-grid" class="vowel-group-grid"></div>
          </div>
        </details>
        <div class="option-row">
          <label
            for="pitch-slider"
            title="Past de toonhoogte van de spraak aan. Hogere waarden klinken hoger."
            >Toonhoogte</label
          >
          <input type="range" id="pitch-slider" min="0" max="2" step="0.1" />
          <span id="pitch-value" class="slider-value"></span>
        </div>
        <div class="option-row">
          <label
            for="rate-slider"
            title="Past de spreeksnelheid aan. Hogere waarden zijn sneller."
            >Snelheid</label
          >
          <input type="range" id="rate-slider" min="0.1" max="10" step="0.1" />
          <span id="rate-value" class="slider-value"></span>
        </div>
        <div class="option-row">
          <button
            type="button"
            class="btn ghost"
            id="reset-settings-btn"
            style="padding: 8px 16px; font-size: 14px; width: 100%"
            title="Zet alle instellingen terug naar de standaardwaarden."
          >
            Instellingen resetten
          </button>
        </div>
      </div>
      <div class="modal-actions">
        <button class="btn primary" id="close-options-modal">Sluiten</button>
      </div>
    </dialog>
    <dialog
      id="leaderboard-modal"
      aria-modal="true"
      role="dialog"
      aria-labelledby="leaderboard-modal-title"
    >
      <div class="modal-head">
        <div id="leaderboard-modal-title" class="modal-title">
          üèÜ Barendroom Hall of Fame üèÜ
        </div>
      </div>
      <div class="modal-body">
        <table id="leaderboard-table">
          <thead>
            <tr>
              <th>Datum</th>
              <th>Ontdekker</th>
              <th>Barendroom</th>
            </tr>
          </thead>
          <tbody id="leaderboard-body"></tbody>
        </table>
        <p id="leaderboard-loading" style="text-align: center; display: none">
          Laden...
        </p>
        <p
          id="leaderboard-error"
          style="text-align: center; display: none; color: var(--danger)"
        ></p>
      </div>
      <div class="modal-actions">
        <button class="btn primary" id="close-leaderboard-modal">
          Sluiten
        </button>
      </div>
    </dialog>

    <dialog
      id="spoiler-warning-modal"
      aria-modal="true"
      role="dialog"
      aria-labelledby="spoiler-warning-modal-title"
    >
      <div class="modal-head">
        <div id="spoiler-warning-modal-title" class="modal-title">
          Spoiler Waarschuwing
        </div>
      </div>
      <div class="modal-body">
        <p>Weet je zeker dat je deze Barendroom wilt onthullen?</p>
      </div>
      <div class="modal-actions">
        <button class="btn ghost" id="spoiler-cancel">Annuleren</button>
        <button class="btn primary" id="spoiler-confirm">
          Toon de Barendroom
        </button>
      </div>
    </dialog>

    <dialog
      id="definitions-modal"
      aria-modal="true"
      role="dialog"
      aria-labelledby="definitions-modal-title"
    >
      <div class="modal-head">
        <div id="definitions-modal-title" class="modal-title">
          Barend Woordenboek
        </div>
      </div>
      <div class="modal-body">
        <div id="definitions-container"><p>Definities laden...</p></div>
      </div>
      <div class="modal-actions">
        <button class="btn primary" id="close-definitions-modal">OK</button>
      </div>
    </dialog>

    <dialog
      id="instructions-modal"
      aria-modal="true"
      role="dialog"
      aria-labelledby="instructions-modal-title"
    >
      <div class="modal-head">
        <div id="instructions-modal-title" class="modal-title">Instructies</div>
      </div>
      <div class="modal-body">
        <p>
          De <strong>Barend Generator</strong> cre√´ert een 'Barendogram': een
          matrix van woordvariaties door de klinkergroepen in jouw woord te
          verwisselen.
        </p>
        <p>
          Als alle gegenereerde woorden in het woordenboek staan, heb je een
          <strong>Barendroom</strong> gevonden!
        </p>
        <h3 style="font-weight: 700; color: var(--accent); margin: 16px 0 8px">
          Hoe het werkt
        </h3>
        <p>
          <strong>1. Woord Invoeren:</strong> Typ een woord in het invoerveld.
          Het woord moet minstens twee verschillende klinkergroepen hebben
          (bijv. 'Barend' heeft 'a' en 'e').<br /><br />
          <strong>2. Genereren:</strong> Klik op 'Genereren' om alle combinaties
          te zien. Je kunt ook op 'Verras me' klikken om een willekeurig woord
          te genereren.<br /><br />
          <strong>3. Instellingen:</strong> Gebruik de instellingen om de
          weergave (2D/3D), de toegestane klinkergroepen, en de stem
          instellingen aan te passen.<br /><br />
        </p>
      </div>
      <div class="modal-actions">
        <button class="btn primary" id="close-instructions-modal">OK</button>
      </div>
    </dialog>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script>
      (() => {
        // Morphing title animation
        const title = document.getElementById("title");
        const morphStates = [
          "morph-state-barend",
          "morph-state-barand",
          "morph-state-berand",
          "morph-state-berend",
        ];
        let currentMorphState = 0;
        function morphTitle() {
          title.classList.remove(morphStates[currentMorphState]);
          currentMorphState = (currentMorphState + 1) % morphStates.length;
          title.classList.add(morphStates[currentMorphState]);
        }
        title.classList.add(morphStates[currentMorphState]);
        setInterval(morphTitle, 2000);

        // New Menu Toggle Logic
        const menuToggle = document.getElementById("menu-toggle");
        const controlsContainer = document.querySelector(".top-left-controls");
        if (menuToggle) {
          menuToggle.addEventListener("click", () => {
            const isOpen = controlsContainer.classList.toggle("menu-open");
            menuToggle.setAttribute("aria-expanded", isOpen);
          });
          document.addEventListener("click", (e) => {
            if (
              !controlsContainer.contains(e.target) &&
              controlsContainer.classList.contains("menu-open")
            ) {
              controlsContainer.classList.remove("menu-open");
              menuToggle.setAttribute("aria-expanded", false);
            }
          });
        }

        // Audio elements for validation
        const correctSound = new Audio("correct.mp3");
        const wrongSound = new Audio("wrong.mp3");
        const victorySound = new Audio("victory.mp3");
        correctSound.preload = "auto";
        wrongSound.preload = "auto";
        victorySound.preload = "auto";

        // Constants & DOM Elements
        const BUTTON_DEPTH = 0.28;
        const TEXT_Z_OFFSET = 0.08;
        const TWO_LETTER_VOWELS = [
          "aa",
          "ee",
          "ii",
          "ie",
          "oo",
          "uu",
          "oe",
          "eu",
          "ui",
          "ij",
          "ei",
          "ai",
          "au",
          "ou",
          "y",
        ];
        const ONE_LETTER_VOWELS = ["a", "e", "i", "o", "u"];
        const form = document.getElementById("scramble-form");
        const input = document.getElementById("word");
        const grid = document.getElementById("grid");
        const outputCard = document.getElementById("output-card");
        const canvasContainer = document.getElementById("canvas-container");
        const canvas = document.getElementById("three-canvas");
        const dimensionInfo = document.getElementById("dimension-info");
        const btnStop = document.getElementById("stop");
        const randomWordBtn = document.getElementById("random-word-btn");

        // Modals
        const modal = document.getElementById("modal");
        const closeModal = document.getElementById("close-modal");
        const optionsBtn = document.getElementById("options-btn");
        const optionsModal = document.getElementById("options-modal");
        const closeOptionsModal = document.getElementById(
          "close-options-modal",
        );
        const validVowelsList = document.getElementById("valid-vowels-list");
        const warningModal = document.getElementById("warning-modal");
        const warningModalText = document.getElementById("warning-modal-text");
        const confirmProceedBtn = document.getElementById("confirm-proceed");
        const confirmCancelBtn = document.getElementById("confirm-cancel");
        const leaderboardBtn = document.getElementById("leaderboard-btn");
        const leaderboardModal = document.getElementById("leaderboard-modal");
        const closeLeaderboardModal = document.getElementById(
          "close-leaderboard-modal",
        );
        const spoilerWarningModal = document.getElementById(
          "spoiler-warning-modal",
        );
        const spoilerCancelBtn = document.getElementById("spoiler-cancel");
        const spoilerConfirmBtn = document.getElementById("spoiler-confirm");
        const leaderboardBody = document.getElementById("leaderboard-body");
        const helpBtn = document.getElementById("help-btn");
        const instructionsModal = document.getElementById("instructions-modal");
        const closeInstructionsModal = document.getElementById(
          "close-instructions-modal",
        );
        const definitionsBtn = document.getElementById("definitions-btn");
        const definitionsModal = document.getElementById("definitions-modal");
        const closeDefinitionsModal = document.getElementById(
          "close-definitions-modal",
        );

        // Options Controls
        const enable3dCheckbox = document.getElementById("enable-3d");
        const enableValidationHighlightCheckbox = document.getElementById(
          "enable-validation-highlight",
        );
        const languageSelect = document.getElementById("language-select");
        const pitchSlider = document.getElementById("pitch-slider");
        const rateSlider = document.getElementById("rate-slider");
        const pitchValueSpan = document.getElementById("pitch-value");
        const rateValueSpan = document.getElementById("rate-value");
        const vowelOptionsDetails = document.getElementById(
          "vowel-options-details",
        );
        const vowelGroupGrid = document.getElementById("vowel-group-grid");
        const vowelsSelectAllBtn = document.getElementById("vowels-all");
        const vowelsSelectNoneBtn = document.getElementById("vowels-none");
        const resetSettingsBtn = document.getElementById("reset-settings-btn");
        // App State
        let scene, camera, renderer;
        let wordButtons = [];
        let speaking = false;
        let raycaster, mouse;
        let activeMaterial, validMaterial, invalidMaterial;
        let settings = {};
        let totalCombinations = 0;
        let currentPage = 1;
        const itemsPerPage = 100;
        let currentAnalysis = {};
        let currentPlaybackId = null;
        const wordlist = new Set();
        let wordlistLoaded = false;
        let barendroomAnimationId = null;
        let combinationOrder = [];
        let _pendingSpoilerReveal = null;
        let definitionsLoaded = false;

        // DOM Refs for dynamic elements
        const comboCount = document.getElementById("combo-count");
        const paginationControls = document.getElementById(
          "pagination-controls",
        );
        const pageIndicator = document.getElementById("page-indicator");
        const prevPageBtn = document.getElementById("prev-page");
        const nextPageBtn = document.getElementById("next-page");
        const shareBtn = document.getElementById("share-btn");
        const randomizeBtn = document.getElementById("randomize-btn");

        if (randomWordBtn) randomWordBtn.disabled = true;

        // --- Definitions ---
        async function loadDefinitions() {
          if (definitionsLoaded) return;
          const container = document.getElementById("definitions-container");
          try {
            const response = await fetch("definitions.yaml");
            if (!response.ok) {
              throw new Error(
                `Bestand niet gevonden (status: ${response.status})`,
              );
            }
            const yamlText = await response.text();
            const data = jsyaml.load(yamlText);
            data.sort((a, b) => a.term.localeCompare(b.term));
            container.innerHTML = "";
            const dl = document.createElement("dl");
            dl.style.margin = "0";
            dl.style.padding = "0";

            data.forEach((item) => {
              const termId =
                "def-term-" + item.term.toLowerCase().replace(/\s+/g, "-");

              const dt = document.createElement("dt");
              dt.id = termId;
              dt.textContent = item.term;
              dt.style.fontWeight = "700";
              dt.style.color = "var(--text)";
              dt.style.padding = "2px 4px";
              dt.style.margin = "0 -4px";

              const dd = document.createElement("dd");
              dd.style.marginLeft = "16px";
              dd.style.marginBottom = "10px";
              dd.style.color = "var(--muted)";
              dd.style.padding = "2px 4px";
              dd.style.margin = "0 -4px 10px 12px";

              // Parse definition for [[links]]
              const definitionParts = item.definition.split(/(\[\[.*?\]\])/g);
              definitionParts.forEach((part) => {
                const match = part.match(/\[\[(.*?)\]\]/);
                if (match) {
                  const term = match[1];
                  const link = document.createElement("span");
                  link.className = "def-link";
                  link.textContent = term;
                  link.dataset.term = term;
                  dd.appendChild(link);
                } else {
                  dd.appendChild(document.createTextNode(part));
                }
              });

              dl.appendChild(dt);
              dl.appendChild(dd);
            });
            container.appendChild(dl);
            definitionsLoaded = true;
          } catch (err) {
            container.innerHTML = `<p style="color: var(--danger);">Kon definities niet laden: ${err.message}</p>`;
            console.error("Error loading definitions:", err);
          }
        }

        // --- Leaderboard ---
        async function loadLeaderboard() {
          const loadingIndicator = document.getElementById(
            "leaderboard-loading",
          );
          const errorIndicator = document.getElementById("leaderboard-error");
          loadingIndicator.style.display = "block";
          errorIndicator.style.display = "none";
          leaderboardBody.innerHTML = "";

          try {
            const response = await fetch("leaderboard.yaml");
            if (!response.ok) {
              throw new Error(
                `Leaderboard-bestand niet gevonden (status: ${response.status})`,
              );
            }
            const yamlText = await response.text();
            const data = jsyaml.load(yamlText);

            if (!data || data.length === 0) {
              leaderboardBody.innerHTML =
                '<tr><td colspan="3" style="text-align:center;">Nog geen Barendromen ontdekt!</td></tr>';
              return;
            }

            data.forEach((item) => {
              const row = leaderboardBody.insertRow();
              row.insertCell(0).textContent = item.date || "N/A";
              row.insertCell(1).textContent = item.discoverer || "Anoniem";
              const wordCell = row.insertCell(2);

              const showBtn = document.createElement("button");
              showBtn.textContent = "Toon";
              showBtn.className = "btn-tiny";
              showBtn.dataset.word = item.word;
              showBtn.addEventListener("click", () => {
                _pendingSpoilerReveal = { cell: wordCell, word: item.word };
                spoilerWarningModal.showModal();
              });
              wordCell.appendChild(showBtn);
            });
          } catch (err) {
            errorIndicator.textContent = `Fout bij laden leaderboard: ${err.message}`;
            errorIndicator.style.display = "block";
            console.error("Error loading leaderboard:", err);
          } finally {
            loadingIndicator.style.display = "none";
          }
        }

        // --- Barendroom Feature ---
        async function loadWordlist() {
          try {
            const response = await fetch("wordlist.txt");
            if (!response.ok) {
              console.error("Wordlist not found or failed to load.");
              if (randomWordBtn) {
                randomWordBtn.disabled = true;
                randomWordBtn.title = "Woordenlijst kon niet worden geladen.";
              }
              return;
            }
            const text = await response.text();
            text.split("\n").forEach((word) => {
              if (word) wordlist.add(word.trim().toLowerCase());
            });
            wordlistLoaded = true;
            if (randomWordBtn) randomWordBtn.disabled = false;
            console.log(`Wordlist loaded with ${wordlist.size} words.`);
          } catch (e) {
            console.error("Error loading wordlist:", e);
            if (randomWordBtn) {
              randomWordBtn.disabled = true;
              randomWordBtn.title = "Woordenlijst kon niet worden geladen.";
            }
          }
        }

        function checkAllWordsExist(analysis) {
          if (!wordlistLoaded || wordlist.size === 0) return false;
          const count = Math.pow(
            analysis.uniqueGroups.length,
            analysis.groups.length,
          );
          // Let's not check astronomically large numbers of words
          if (count > 50000) return false;
          for (let i = 0; i < count; i++) {
            const variant = buildNthVariant(i, analysis);
            if (!wordlist.has(variant.toLowerCase())) {
              return false;
            }
          }
          return true;
        }

        function playBarendroomAndAnimate(cellsToPlay) {
          stopSpeech(true);
          const playbackId = Date.now();
          currentPlaybackId = playbackId;
          speaking = true;

          const executeValidationPass = (onComplete) => {
            let index = 0;
            const step = () => {
              if (currentPlaybackId !== playbackId) {
                cellsToPlay.forEach((c) =>
                  c.classList.remove("valid", "invalid"),
                );
                return;
              }
              if (index >= cellsToPlay.length) {
                onComplete();
                return;
              }
              const cell = cellsToPlay[index];
              const word = cell.textContent.toLowerCase();
              cell.scrollIntoView({ behavior: "smooth", block: "center" });

              if (wordlist.has(word)) {
                cell.classList.add("valid", "bounce");
                correctSound.currentTime = 0;
                correctSound
                  .play()
                  .catch((e) => console.error("Audio play failed:", e));
              } else {
                cell.classList.add("invalid", "shake");
                wrongSound.currentTime = 0;
                wrongSound
                  .play()
                  .catch((e) => console.error("Audio play failed:", e));
              }

              setTimeout(() => cell.classList.remove("bounce", "shake"), 500);

              index++;
              setTimeout(step, 300);
            };
            step();
          };

          const executeSpeakingPass = (onComplete) => {
            let index = 0;
            const step = () => {
              if (currentPlaybackId !== playbackId || !speaking) {
                clearActive();
                if (currentPlaybackId === null) speaking = false;
                return;
              }
              if (index >= cellsToPlay.length) {
                clearActive();
                onComplete();
                return;
              }
              const cell = cellsToPlay[index];
              const word = cell.textContent;
              clearActive();
              cell.scrollIntoView({ behavior: "smooth", block: "center" });
              cell.classList.add("active");
              speakWord(word, () => {
                index++;
                step();
              });
            };
            step();
          };

          if (settings.enableValidationHighlight && wordlistLoaded) {
            executeSpeakingPass(() => {
              setTimeout(() => {
                executeValidationPass(() => {
                  speaking = false;
                  setTimeout(() => startBouncingAnimation(cellsToPlay), 200);
                });
              }, 750);
            });
          } else {
            executeSpeakingPass(() => {
              speaking = false;
              startBouncingAnimation(cellsToPlay);
            });
          }
        }

        function playBarendroom3DAndAnimate(buttonsToAnimate) {
          stopSpeech(true);
          const playbackId = Date.now();
          currentPlaybackId = playbackId;
          speaking = true;

          const animate3DObject = (object, animationType) => {
            const originalPos = object.position.clone();
            const originalScale = object.scale.clone();
            let startTime = null;
            const duration = 500;

            function frame(currentTime) {
              if (!startTime) startTime = currentTime;
              const elapsed = currentTime - startTime;
              const progress = Math.min(elapsed / duration, 1);

              if (animationType === "bounce") {
                const scale = 1 + 0.2 * Math.sin(progress * Math.PI);
                object.scale.set(scale, scale, scale);
              } else if (animationType === "shake") {
                const shakeAmount = 0.05 * Math.sin(progress * Math.PI * 4);
                object.position.x = originalPos.x + shakeAmount;
              }

              if (progress < 1) {
                requestAnimationFrame(frame);
              } else {
                object.position.copy(originalPos);
                object.scale.copy(originalScale);
              }
            }
            requestAnimationFrame(frame);
          };

          const executeSpeakingPass = (onComplete) => {
            let index = 0;
            const step = () => {
              if (currentPlaybackId !== playbackId || !speaking) {
                clearActive();
                if (currentPlaybackId === null) speaking = false;
                return;
              }
              if (index >= buttonsToAnimate.length) {
                clearActive();
                onComplete();
                return;
              }
              const buttonGroup = buttonsToAnimate[index];
              const word = buttonGroup.userData.word;
              clearActive();
              buttonGroup.children[0].material = activeMaterial;
              speakWord(word, () => {
                index++;
                step();
              });
            };
            step();
          };

          const executeValidationPass = (onComplete) => {
            let index = 0;
            const step = () => {
              if (currentPlaybackId !== playbackId) {
                buttonsToAnimate.forEach(
                  (btn) =>
                    (btn.children[0].material = btn.userData.baseMaterial),
                );
                return;
              }
              if (index >= buttonsToAnimate.length) {
                onComplete();
                return;
              }
              const buttonGroup = buttonsToAnimate[index];
              const word = buttonGroup.userData.word.toLowerCase();

              if (wordlist.has(word)) {
                buttonGroup.children[0].material = validMaterial;
                animate3DObject(buttonGroup, "bounce");
                correctSound.currentTime = 0;
                correctSound
                  .play()
                  .catch((e) => console.error("Audio play failed:", e));
              } else {
                buttonGroup.children[0].material = invalidMaterial;
                animate3DObject(buttonGroup, "shake");
                wrongSound.currentTime = 0;
                wrongSound
                  .play()
                  .catch((e) => console.error("Audio play failed:", e));
              }

              index++;
              setTimeout(step, 300);
            };
            step();
          };

          executeSpeakingPass(() => {
            if (currentPlaybackId !== playbackId) return;
            setTimeout(() => {
              executeValidationPass(() => {
                if (currentPlaybackId !== playbackId) return;
                speaking = false;

                const allWords = buttonsToAnimate.map(
                  (btn) => btn.userData.word,
                );
                canvasContainer.style.display = "none";
                grid.style.display = "grid";
                grid.innerHTML = "";
                grid.style.gridTemplateColumns = "repeat(2, 1fr)";
                grid.style.position = "static";
                grid.style.height = "auto";

                const cellsToBounce = [];
                allWords.forEach((word) => {
                  const cell = document.createElement("div");
                  cell.className = "cell";
                  cell.textContent = word;
                  if (wordlist.has(word.toLowerCase())) {
                    cell.classList.add("valid");
                  } else {
                    cell.classList.add("invalid");
                  }
                  grid.appendChild(cell);
                  fitText(cell);
                  cellsToBounce.push(cell);
                });

                setTimeout(() => startBouncingAnimation(cellsToBounce), 200);
              });
            }, 750);
          });
        }

        function startBarendroomSequence(analysis) {
          const allWords = [];
          const count = Math.pow(
            analysis.uniqueGroups.length,
            analysis.groups.length,
          );
          for (let i = 0; i < count; i++) {
            const originalIndex = combinationOrder[i];
            allWords.push(buildNthVariant(originalIndex, analysis));
          }

          const use3D =
            settings.enable3d &&
            analysis.uniqueGroups.length >= 3 &&
            allWords.length <= itemsPerPage;

          if (use3D) {
            outputCard.style.display = "block";
            grid.style.display = "none";
            canvasContainer.style.display = "block";
            paginationControls.style.display = "none";
            comboCount.textContent = `${count.toLocaleString("nl-NL")} combinaties`;

            render3DVisualization(
              allWords.map((word, i) => ({ word, index: i })),
              analysis.uniqueGroups.length,
            );

            setTimeout(() => playBarendroom3DAndAnimate(wordButtons), 100);
          } else {
            outputCard.style.display = "block";
            canvasContainer.style.display = "none";
            grid.style.display = "grid";
            grid.innerHTML = "";
            grid.style.gridTemplateColumns = "repeat(2, 1fr)";

            grid.style.position = "static";
            grid.style.height = "auto";
            grid.onscroll = null;
            paginationControls.style.display = "none";
            comboCount.textContent = `${count.toLocaleString("nl-NL")} combinaties`;
            const originalCells = [];
            allWords.forEach((word, index) => {
              const cell = document.createElement("div");
              cell.className = "cell";
              cell.textContent = word;
              cell.dataset.index = index;
              grid.appendChild(cell);
              fitText(cell);
              originalCells.push(cell);
            });

            playBarendroomAndAnimate(originalCells);
          }
        }

        function startBouncingAnimation(originalCells) {
          victorySound.currentTime = 0;
          victorySound
            .play()
            .catch((e) => console.error("Audio play failed:", e));
          const overlay = document.createElement("div");
          overlay.id = "barendroom-2d-overlay";

          const canvas = document.createElement("canvas");
          canvas.id = "trace-canvas";
          overlay.appendChild(canvas);

          document.body.appendChild(overlay);

          const ctx = canvas.getContext("2d");
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;

          const bouncingButtons = originalCells.map((cell) => {
            const rect = cell.getBoundingClientRect();
            overlay.appendChild(cell);

            cell.classList.add("bouncing-cell");
            // Keep valid/invalid, remove active
            cell.classList.remove("cell", "active");
            cell.style.width = `${rect.width}px`;
            cell.style.height = `${rect.height}px`;
            cell.style.left = "0px";
            cell.style.top = "0px";
            cell.style.cursor = "grab";

            return {
              el: cell,
              x: rect.left,
              y: rect.top,
              vx: Math.random() * 8 - 4,
              vy: Math.random() * -10 - 5,
              width: rect.width,
              height: rect.height,
              trace: [],
              isDragged: false,
            };
          });
          outputCard.style.display = "none";
          let draggedButton = null;
          let dragOffsetX = 0,
            dragOffsetY = 0;
          let lastPos = { x: 0, y: 0 };
          const velocityHistory = [];
          const MAX_HISTORY = 5;
          let gravity = { x: 0, y: 0.3 };
          const friction = 0.995;
          const bounceFactor = 0.8;
          const restitution = 0.65;
          const maxTraceLength = 20;
          const MAX_SPEED = 40;
          const handleOrientation = (event) => {
            if (event.accelerationIncludingGravity) {
              const GRAVITY_SCALE = 0.3 / 9.8;
              const gx = -event.accelerationIncludingGravity.x;
              const gy = event.accelerationIncludingGravity.y;
              gravity.x = gx * GRAVITY_SCALE;
              gravity.y = gy * GRAVITY_SCALE;
            }
          };

          if (
            window.DeviceMotionEvent &&
            typeof DeviceMotionEvent.requestPermission === "function"
          ) {
            DeviceMotionEvent.requestPermission()
              .then((permissionState) => {
                if (permissionState === "granted") {
                  window.addEventListener("devicemotion", handleOrientation);
                }
              })
              .catch(console.error);
          } else {
            window.addEventListener("devicemotion", handleOrientation);
          }
          const confetti = [];
          const CONFETTI_COUNT = 150;
          const confettiColors = ["#6ee7f5", "#9b8cff", "#4ade80", "#ff4d6d"];
          for (let i = 0; i < CONFETTI_COUNT; i++) {
            confetti.push({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height - canvas.height,
              width: Math.random() * 6 + 4,
              height: Math.random() * 12 + 8,
              vx: Math.random() * 2 - 1,
              vy: Math.random() * 2 + 2,
              rotation: Math.random() * Math.PI * 2,
              rotationSpeed: (Math.random() - 0.5) * 0.1,
              color:
                confettiColors[
                  Math.floor(Math.random() * confettiColors.length)
                ],
            });
          }
          function animate() {
            ctx.fillStyle = "#0f1226";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            confetti.forEach((c) => {
              c.x += c.vx;
              c.y += c.vy;
              c.rotation += c.rotationSpeed;
              if (c.y > canvas.height + 20) {
                c.x = Math.random() * canvas.width;
                c.y = -20;
              }
              ctx.save();
              ctx.translate(c.x + c.width / 2, c.y + c.height / 2);
              ctx.rotate(c.rotation);
              ctx.fillStyle = c.color;
              ctx.fillRect(-c.width / 2, -c.height / 2, c.width, c.height);
              ctx.restore();
            });
            bouncingButtons.forEach((btn) => {
              if (!btn.isDragged) {
                btn.vx += gravity.x;
                btn.vy += gravity.y;
                btn.vx *= friction;
                btn.vy *= friction;
                btn.x += btn.vx;
                btn.y += btn.vy;
                if (btn.y + btn.height > window.innerHeight) {
                  btn.y = window.innerHeight - btn.height;
                  btn.vy *= -bounceFactor;
                }
                if (btn.x + btn.width > window.innerWidth) {
                  btn.x = window.innerWidth - btn.width;
                  btn.vx *= -bounceFactor;
                }
                if (btn.x < 0) {
                  btn.x = 0;
                  btn.vx *= -bounceFactor;
                }
                if (btn.y < 0) {
                  btn.y = 0;
                  btn.vy *= -bounceFactor;
                }
              }
            });

            for (let i = 0; i < bouncingButtons.length; i++) {
              for (let j = i + 1; j < bouncingButtons.length; j++) {
                const btn1 = bouncingButtons[i],
                  btn2 = bouncingButtons[j];
                const dx = btn1.x + btn1.width / 2 - (btn2.x + btn2.width / 2),
                  dy = btn1.y + btn1.height / 2 - (btn2.y + btn2.height / 2);
                const combinedHalfWidths = (btn1.width + btn2.width) / 2,
                  combinedHalfHeights = (btn1.height + btn2.height) / 2;
                const overlapX = combinedHalfWidths - Math.abs(dx),
                  overlapY = combinedHalfHeights - Math.abs(dy);
                if (overlapX > 0 && overlapY > 0) {
                  if (overlapX < overlapY) {
                    const nx = dx > 0 ? 1 : -1;
                    btn1.x += (overlapX * nx) / 2;
                    btn2.x -= (overlapX * nx) / 2;
                    const rvx = btn2.vx - btn1.vx,
                      impulse = -(1 + restitution) * rvx * nx;
                    btn1.vx -= impulse / 2;
                    btn2.vx += impulse / 2;
                  } else {
                    const ny = dy > 0 ? 1 : -1;
                    btn1.y += (overlapY * ny) / 2;
                    btn2.y -= (overlapY * ny) / 2;
                    const rvy = btn2.vy - btn1.vy,
                      impulse = -(1 + restitution) * rvy * ny;
                    btn1.vy -= impulse / 2;
                    btn2.vy += impulse / 2;
                  }
                }
              }
            }
            bouncingButtons.forEach((btn) => {
              const speed = Math.sqrt(btn.vx * btn.vx + btn.vy * btn.vy);
              if (speed > MAX_SPEED) {
                btn.vx = (btn.vx / speed) * MAX_SPEED;
                btn.vy = (btn.vy / speed) * MAX_SPEED;
              }
              btn.el.style.transform = `translate(${btn.x}px, ${btn.y}px)`;
              btn.trace.push({
                x: btn.x + btn.width / 2,
                y: btn.y + btn.height / 2,
              });
              if (btn.trace.length > maxTraceLength) btn.trace.shift();
              if (btn.trace.length > 1) {
                ctx.beginPath();
                ctx.moveTo(btn.trace[0].x, btn.trace[0].y);
                for (let k = 1; k < btn.trace.length; k++)
                  ctx.lineTo(btn.trace[k].x, btn.trace[k].y);
                const grad = ctx.createLinearGradient(
                  btn.trace[0].x,
                  btn.trace[0].y,
                  btn.trace[btn.trace.length - 1].x,
                  btn.trace[btn.trace.length - 1].y,
                );
                grad.addColorStop(0, "rgba(110, 231, 245, 0)");
                grad.addColorStop(1, "rgba(155, 140, 255, 0.7)");
                ctx.strokeStyle = grad;
                ctx.lineWidth = 2;
                ctx.stroke();
              }
            });
            barendroomAnimationId = requestAnimationFrame(animate);
          }

          const handleStart = (clientX, clientY) => {
            for (let i = bouncingButtons.length - 1; i >= 0; i--) {
              const btn = bouncingButtons[i];
              if (
                clientX >= btn.x &&
                clientX <= btn.x + btn.width &&
                clientY >= btn.y &&
                clientY <= btn.y + btn.height
              ) {
                draggedButton = btn;
                stopSpeech(true);
                speakWord(draggedButton.el.textContent);
                draggedButton.isDragged = true;
                draggedButton.el.style.cursor = "grabbing";
                draggedButton.el.style.zIndex = 1000;
                dragOffsetX = clientX - btn.x;
                dragOffsetY = clientY - btn.y;
                lastPos = { x: clientX, y: clientY };
                velocityHistory.length = 0;
                break;
              }
            }
          };
          const handleMove = (clientX, clientY) => {
            if (draggedButton) {
              draggedButton.x = clientX - dragOffsetX;
              draggedButton.y = clientY - dragOffsetY;
              const vx = clientX - lastPos.x,
                vy = clientY - lastPos.y;
              velocityHistory.push({ vx, vy });
              if (velocityHistory.length > MAX_HISTORY) velocityHistory.shift();
              lastPos = { x: clientX, y: clientY };
            }
          };
          const handleEnd = () => {
            if (draggedButton) {
              draggedButton.isDragged = false;
              draggedButton.el.style.cursor = "grab";
              draggedButton.el.style.zIndex = 1;
              if (velocityHistory.length > 0) {
                const avg = velocityHistory.reduce(
                  (acc, v) => ({ vx: acc.vx + v.vx, vy: acc.vy + v.vy }),
                  { vx: 0, vy: 0 },
                );
                draggedButton.vx = avg.vx / velocityHistory.length;
                draggedButton.vy = avg.vy / velocityHistory.length;
              }
              draggedButton = null;
            }
          };
          overlay.addEventListener("mousedown", (e) =>
            handleStart(e.clientX, e.clientY),
          );
          overlay.addEventListener("mousemove", (e) =>
            handleMove(e.clientX, e.clientY),
          );
          window.addEventListener("mouseup", handleEnd);
          overlay.addEventListener(
            "touchstart",
            (e) => {
              e.preventDefault();
              handleStart(e.touches[0].clientX, e.touches[0].clientY);
            },
            { passive: false },
          );
          overlay.addEventListener(
            "touchmove",
            (e) => {
              e.preventDefault();
              if (draggedButton && e.touches.length)
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            },
            { passive: false },
          );
          window.addEventListener("touchend", handleEnd);
          animate();

          const popup = document.createElement("div");
          popup.className = "barendroom-congrats-popup";
          popup.innerHTML = `<h2>Gefeliciteerd!</h2><p>Je hebt een Barendroom gevonden!</p>`;
          popup.addEventListener("touchstart", (e) => e.stopPropagation());
          const popupActions = document.createElement("div");
          popupActions.className = "barendroom-popup-actions";
          const shareBarendroomBtn = document.createElement("button");
          shareBarendroomBtn.className = "btn ghost";
          shareBarendroomBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/></svg>Delen`;
          const minimizeBtn = document.createElement("button");
          minimizeBtn.className = "btn ghost";
          minimizeBtn.textContent = "Minimaliseren";
          const returnBtn = document.createElement("button");
          returnBtn.className = "btn primary";
          returnBtn.textContent = "Terug";
          popupActions.appendChild(shareBarendroomBtn);
          popupActions.appendChild(minimizeBtn);
          popupActions.appendChild(returnBtn);
          popup.appendChild(popupActions);
          overlay.appendChild(popup);
          shareBarendroomBtn.addEventListener("click", async () => {
            const wordToShare = input.value.trim();
            const compressed = compressSettings(settings);
            const baseUrl = window.location.origin + window.location.pathname;
            let shareUrl = `${baseUrl}?word=${encodeURIComponent(wordToShare)}`;
            if (Object.keys(compressed).length > 0) {
              shareUrl += `&s=${encodeURIComponent(btoa(JSON.stringify(compressed)))}`;
            }
            const shareData = {
              title: "Barend Generator",
              text: `Ik heb een Barendroom gevonden: "${wordToShare}"! üéâ`,
              url: shareUrl,
            };
            try {
              if (navigator.share) {
                await navigator.share(shareData);
              } else {
                await navigator.clipboard.writeText(shareUrl);
                shareBarendroomBtn.textContent = "‚úÖ Gekopieerd!";
                setTimeout(() => {
                  shareBarendroomBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px;"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/></svg>Delen`;
                }, 2000);
              }
            } catch (err) {
              console.error("Share failed:", err);
            }
          });
          minimizeBtn.addEventListener("click", () => {
            popup.style.transform = "translate(-50%, -50%) scale(0)";
            popup.style.opacity = "0";
            popup.style.pointerEvents = "none";
            if (!document.getElementById("restore-popup-btn")) {
              const restoreBtn = document.createElement("button");
              restoreBtn.id = "restore-popup-btn";
              restoreBtn.className = "btn ghost";
              restoreBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`;
              restoreBtn.style.cssText =
                "position:absolute; top:20px; left:50%; transform:translateX(-50%); z-index:10002; width:48px; height:48px; border-radius:50%; padding:0;";
              const restoreAction = () => {
                popup.style.transform = "translate(-50%, -50%) scale(1)";
                popup.style.opacity = "1";
                popup.style.pointerEvents = "auto";
                if (overlay.contains(restoreBtn))
                  overlay.removeChild(restoreBtn);
              };
              restoreBtn.addEventListener("click", restoreAction);
              restoreBtn.addEventListener("touchstart", (e) => {
                e.stopPropagation();
                restoreAction();
              });
              overlay.appendChild(restoreBtn);
            }
          });
          returnBtn.addEventListener("click", () => {
            cancelAnimationFrame(barendroomAnimationId);
            barendroomAnimationId = null;
            document.body.removeChild(overlay);
            window.removeEventListener("devicemotion", handleOrientation);
            outputCard.style.display = "block";
            displayPage(1);
          });
        }

        // --- Settings Management ---
        const defaultAllowedVowels = TWO_LETTER_VOWELS.reduce(
          (acc, vg) => ({ ...acc, [vg]: vg !== "y" }), // Set 'y' to false, all others to true
          {},
        );

        const defaultSettings = {
          enable3d: false,
          enableValidationHighlight: false,
          language: "nl-NL",
          allowedVowelGroups: { ...defaultAllowedVowels },
          vowelOptionsExpanded: false,
          pitch: 1.0,
          rate: 1.0,
        };
        // Create a mask with all bits set to 1
        const allVowelsOnMask = (1 << TWO_LETTER_VOWELS.length) - 1;
        // Find the position of 'y' to turn its corresponding bit off
        const yIndex = TWO_LETTER_VOWELS.indexOf("y");
        // The new default mask has the bit for 'y' set to 0
        const DEFAULT_VOWEL_MASK = allVowelsOnMask & ~(1 << yIndex);

        function compressSettings(settingsToCompress) {
          const compressed = {};
          const defaults = defaultSettings;
          if (settingsToCompress.enable3d !== defaults.enable3d)
            compressed.d = settingsToCompress.enable3d ? 1 : 0;
          if (settingsToCompress.enableValidationHighlight) compressed.h = 1;
          if (
            settingsToCompress.vowelOptionsExpanded !==
            defaults.vowelOptionsExpanded
          )
            compressed.e = settingsToCompress.vowelOptionsExpanded ? 1 : 0;
          if (settingsToCompress.pitch !== defaults.pitch)
            compressed.p = settingsToCompress.pitch;
          if (settingsToCompress.rate !== defaults.rate)
            compressed.r = settingsToCompress.rate;
          let mask = 0;
          TWO_LETTER_VOWELS.forEach((vowel, index) => {
            if (settingsToCompress.allowedVowelGroups[vowel])
              mask |= 1 << index;
          });
          if (mask !== DEFAULT_VOWEL_MASK) compressed.v = mask;
          return compressed;
        }

        function decompressSettings(compressed) {
          const decompressed = JSON.parse(JSON.stringify(defaultSettings));
          if (compressed.d !== undefined)
            decompressed.enable3d = compressed.d === 1;
          if (compressed.h !== undefined)
            decompressed.enableValidationHighlight = compressed.h === 1;
          if (compressed.e !== undefined)
            decompressed.vowelOptionsExpanded = compressed.e === 1;
          if (compressed.p !== undefined) decompressed.pitch = compressed.p;
          if (compressed.r !== undefined) decompressed.rate = compressed.r;

          const mask =
            compressed.v !== undefined ? compressed.v : DEFAULT_VOWEL_MASK;
          const allowed = {};
          TWO_LETTER_VOWELS.forEach((vowel, index) => {
            allowed[vowel] = (mask & (1 << index)) !== 0;
          });
          decompressed.allowedVowelGroups = allowed;
          return decompressed;
        }

        function getActiveVowelGroups() {
          const allowed = Object.entries(settings.allowedVowelGroups || {})
            .filter(([, isAllowed]) => isAllowed)
            .map(([vg]) => vg);
          return [...allowed, ...ONE_LETTER_VOWELS].sort(
            (a, b) => b.length - a.length,
          );
        }

        function updateValidVowelsDisplay() {
          const activeVowels = getActiveVowelGroups();
          validVowelsList.textContent = activeVowels.join(" ");
        }

        function saveSettings() {
          settings.enable3d = enable3dCheckbox.checked;
          settings.enableValidationHighlight =
            enableValidationHighlightCheckbox.checked;
          settings.language = languageSelect.value;
          settings.pitch = parseFloat(pitchSlider.value);
          settings.rate = parseFloat(rateSlider.value);
          settings.vowelOptionsExpanded = vowelOptionsDetails.open;
          const newAllowed = {};
          vowelGroupGrid
            .querySelectorAll(".toggle-switch")
            .forEach((toggle) => {
              newAllowed[toggle.dataset.vowelGroup] = toggle.checked;
            });
          settings.allowedVowelGroups = newAllowed;
          localStorage.setItem("barendGenSettings", JSON.stringify(settings));
          updateValidVowelsDisplay();
        }

        function updateSliderValues() {
          pitchValueSpan.textContent = parseFloat(pitchSlider.value).toFixed(2);
          rateValueSpan.textContent = parseFloat(rateSlider.value).toFixed(2);
        }

        function applySettings(newSettings) {
          settings = { ...defaultSettings, ...newSettings };
          settings.allowedVowelGroups = {
            ...defaultAllowedVowels,
            ...(settings.allowedVowelGroups || {}),
          };

          enable3dCheckbox.checked = settings.enable3d;
          enableValidationHighlightCheckbox.checked =
            settings.enableValidationHighlight;
          languageSelect.value = settings.language;
          pitchSlider.value = settings.pitch;
          rateSlider.value = settings.rate;
          vowelOptionsDetails.open = settings.vowelOptionsExpanded;
          if (settings.allowedVowelGroups) {
            Object.entries(settings.allowedVowelGroups).forEach(
              ([vg, isAllowed]) => {
                const toggle = document.getElementById(`vowel-toggle-${vg}`);
                if (toggle) toggle.checked = isAllowed;
              },
            );
          }
          updateSliderValues();
          updateValidVowelsDisplay();
        }

        function loadSettings() {
          const saved = localStorage.getItem("barendGenSettings");
          const loadedSettings = saved
            ? JSON.parse(saved)
            : JSON.parse(JSON.stringify(defaultSettings));
          applySettings(loadedSettings);
        }

        // --- Three.js Initialization & Controls ---
        function initThreeJS() {
          if (scene) return;
          scene = new THREE.Scene();
          scene.background = new THREE.Color(0x0f1226);
          renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true,
            alpha: true,
          });
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          camera = new THREE.PerspectiveCamera(
            60,
            canvas.clientWidth / Math.max(1, canvas.clientHeight),
            0.1,
            1000,
          );
          camera.position.set(0, 0, 8);
          camera.lookAt(0, 0, 0);
          const ambientLight = new THREE.AmbientLight(0x6ee7f5, 0.45);
          scene.add(ambientLight);
          const dir = new THREE.DirectionalLight(0x9b8cff, 0.9);
          dir.position.set(5, 10, 5);
          dir.castShadow = true;
          scene.add(dir);

          // Create highlight materials once
          activeMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x9b8cff,
            metalness: 0.1,
            roughness: 0.5,
            emissive: 0x6ee7f5,
            emissiveIntensity: 0.5,
            clearcoat: 0.8,
          });
          validMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x4ade80,
            metalness: 0.1,
            roughness: 0.5,
            emissive: 0x4ade80,
            emissiveIntensity: 0.5,
            clearcoat: 0.8,
          });
          invalidMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xff4d6d,
            metalness: 0.1,
            roughness: 0.5,
            emissive: 0xff4d6d,
            emissiveIntensity: 0.5,
            clearcoat: 0.8,
          });
          let isRot = false,
            rotX = 0,
            rotY = Math.PI / 2,
            camDist = 8;
          let lastTouch = null,
            lastPinch = null;
          const getDist = (a, b) =>
            Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
          const handleRot = (dx, dy, s = 0.01) => {
            rotY += dx * s;
            rotX += dy * s;
            rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotX));
          };
          const handleZoom = (d, s = 0.01) => {
            camDist += d * s;
            camDist = Math.max(3, Math.min(20, camDist));
          };
          canvas.addEventListener("mousedown", (e) => {
            isRot = true;
            lastTouch = { x: e.clientX, y: e.clientY };
          });
          window.addEventListener("mouseup", () => {
            isRot = false;
            lastTouch = null;
          });
          canvas.addEventListener("mousemove", (e) => {
            if (!isRot || !lastTouch) return;
            handleRot(e.clientX - lastTouch.x, e.clientY - lastTouch.y, 0.012);
            lastTouch = { x: e.clientX, y: e.clientY };
          });
          canvas.addEventListener(
            "wheel",
            (e) => {
              e.preventDefault();
              handleZoom(e.deltaY, 0.015);
            },
            { passive: false },
          );
          canvas.addEventListener(
            "touchstart",
            (e) => {
              if (e.touches.length === 1) {
                isRot = true;
                lastTouch = {
                  x: e.touches[0].clientX,
                  y: e.touches[0].clientY,
                };
                lastPinch = null;
              }
              if (e.touches.length === 2) {
                isRot = false;
                lastTouch = null;
                lastPinch = getDist(e.touches[0], e.touches[1]);
              }
            },
            { passive: false },
          );
          canvas.addEventListener(
            "touchmove",
            (e) => {
              e.preventDefault();
              if (e.touches.length === 1 && isRot && lastTouch) {
                handleRot(
                  e.touches[0].clientX - lastTouch.x,
                  e.touches[0].clientY - lastTouch.y,
                  0.015,
                );
                lastTouch = {
                  x: e.touches[0].clientX,
                  y: e.touches[0].clientY,
                };
              } else if (e.touches.length === 2 && lastPinch !== null) {
                const d = getDist(e.touches[0], e.touches[1]);
                handleZoom(lastPinch - d, 0.02);
                lastPinch = d;
              }
            },
            { passive: false },
          );
          canvas.addEventListener(
            "touchend",
            (e) => {
              if (e.touches.length === 0) {
                isRot = false;
                lastTouch = null;
                lastPinch = null;
              } else if (e.touches.length === 1) {
                isRot = true;
                lastTouch = {
                  x: e.touches[0].clientX,
                  y: e.touches[0].clientY,
                };
                lastPinch = null;
              }
            },
            { passive: false },
          );
          const resize = () => {
            const w = canvas.clientWidth,
              h = Math.max(2, canvas.clientHeight);
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            renderer.setPixelRatio(dpr);
            renderer.setSize(w, h, false);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
          };
          new ResizeObserver(resize).observe(canvasContainer);
          resize();
          raycaster = new THREE.Raycaster();
          mouse = new THREE.Vector2();
          const animate = () => {
            requestAnimationFrame(animate);
            camera.position.x = Math.cos(rotY) * Math.cos(rotX) * camDist;
            camera.position.y = Math.sin(rotX) * camDist;
            camera.position.z = Math.sin(rotY) * Math.cos(rotX) * camDist;
            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
          };
          animate();
          const handleClick = (clientX, clientY) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(wordButtons, true);
            if (intersects.length > 0) {
              let obj = intersects[0].object;
              while (obj && !obj.onClick && obj.parent) obj = obj.parent;
              if (obj && obj.onClick) obj.onClick();
            }
          };
          canvas.addEventListener("click", (e) =>
            handleClick(e.clientX, e.clientY),
          );
          canvas.addEventListener("touchend", (e) => {
            if (e.changedTouches && e.changedTouches.length)
              handleClick(
                e.changedTouches[0].clientX,
                e.changedTouches[0].clientY,
              );
          });
        }

        // --- 3D Object Creation ---
        function createRoundedButtonGeometry(
          w = 1.9,
          h = 1.2,
          depth = BUTTON_DEPTH,
          r = 0.16,
        ) {
          const hw = w / 2,
            hh = h / 2,
            radius = Math.min(r, hw, hh);
          const shape = new THREE.Shape();
          shape.moveTo(-hw + radius, -hh);
          shape.lineTo(hw - radius, -hh);
          shape.quadraticCurveTo(hw, -hh, hw, -hh + radius);
          shape.lineTo(hw, hh - radius);
          shape.quadraticCurveTo(hw, hh, hw - radius, hh);
          shape.lineTo(-hw + radius, hh);
          shape.quadraticCurveTo(-hw, hh, -hw, hh - radius);
          shape.lineTo(-hw, -hh + radius);
          shape.quadraticCurveTo(-hw, -hh, -hw + radius, -hh);
          const extrude = new THREE.ExtrudeGeometry(shape, {
            depth,
            bevelEnabled: true,
            bevelThickness: 0.06,
            bevelSize: 0.06,
            bevelSegments: 6,
            curveSegments: 32,
          });
          if (extrude.center) extrude.center();
          return extrude;
        }

        function makeFittedTextMesh(word, planeW = 1.6, planeH = 0.78) {
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          const baseW = 1024,
            baseH = 512;
          const tex = document.createElement("canvas");
          tex.width = Math.floor(baseW * dpr);
          tex.height = Math.floor(baseH * dpr);
          const ctx = tex.getContext("2d", { alpha: true });
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          const pad = 28,
            maxW = baseW - pad * 2,
            maxH = baseH - pad * 2;
          let fs = 120;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          while (fs > 10) {
            ctx.font = `700 ${fs}px Inter, system-ui, sans-serif`;
            if (ctx.measureText(word).width <= maxW && fs * 1.1 <= maxH) break;
            fs -= 2;
          }
          ctx.clearRect(0, 0, baseW, baseH);
          ctx.shadowColor = "rgba(110,231,245,0.14)";
          ctx.shadowBlur = 6;
          ctx.fillStyle = "#e8ebff";
          ctx.font = `700 ${fs}px Inter, system-ui, sans-serif`;
          ctx.fillText(word, baseW / 2, baseH / 2);
          const texture = new THREE.CanvasTexture(tex);
          texture.anisotropy = 4;
          texture.minFilter = THREE.LinearFilter;
          texture.needsUpdate = true;
          const mat = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide,
          });
          const geo = new THREE.PlaneGeometry(planeW, planeH);
          return new THREE.Mesh(geo, mat);
        }

        function createWordButton(word, position, index) {
          const g = new THREE.Group();
          const geom = createRoundedButtonGeometry(
            1.9,
            1.2,
            BUTTON_DEPTH,
            0.18,
          );
          const baseMat = new THREE.MeshPhysicalMaterial({
            color: 0x161a36,
            metalness: 0.05,
            roughness: 0.6,
            clearcoat: 0.6,
            clearcoatRoughness: 0.4,
            opacity: 0.98,
            transparent: true,
          });
          const btn = new THREE.Mesh(geom, baseMat);
          btn.castShadow = true;
          btn.receiveShadow = true;
          g.add(btn);
          const textMesh = makeFittedTextMesh(word, 1.6, 0.78);
          textMesh.position.z = BUTTON_DEPTH / 2 + TEXT_Z_OFFSET;
          g.add(textMesh);
          g.position.set(position.x, position.y, position.z);
          g.userData = {
            word,
            index,
            baseMaterial: baseMat,
            textMesh,
            buttonMesh: btn,
          };
          g.onClick = () => speakSingle(word, g);
          return g;
        }

        // --- Rendering Logic ---
        function generatePositions(dimensions, size) {
          if (dimensions <= 3) dimensions = 3;
          const positions = [];
          const pointSpacing = 2.5,
            cubeMargin = 5.0;
          const sideLength = Math.ceil(Math.pow(size, 1 / dimensions));
          const cubeWidth = (sideLength - 1) * pointSpacing;
          const gridSpacing = cubeWidth + cubeMargin;
          for (let i = 0; i < size; i++) {
            const coords = [];
            let temp_i = i;
            for (let d = 0; d < dimensions; d++) {
              coords.push(temp_i % sideLength);
              temp_i = Math.floor(temp_i / sideLength);
            }
            const centerOffset = (sideLength - 1) / 2.0;
            const localX = (coords[0] - centerOffset) * pointSpacing,
              localY = (coords[1] - centerOffset) * pointSpacing,
              localZ = (coords[2] - centerOffset) * pointSpacing;
            let gridOffsetX =
              dimensions > 3 ? (coords[3] - centerOffset) * gridSpacing : 0;
            let gridOffsetY =
              dimensions > 4 ? (coords[4] - centerOffset) * gridSpacing : 0;
            let gridOffsetZ =
              dimensions > 5 ? (coords[5] - centerOffset) * gridSpacing : 0;
            positions.push({
              x: localX + gridOffsetX,
              y: localY + gridOffsetY,
              z: localZ + gridOffsetZ,
            });
          }
          return positions;
        }

        function fitText(el) {
          const maxFontSize = 32;
          const minFontSize = 10;
          let fontSize = maxFontSize;
          el.style.fontSize = fontSize + "px";
          el.style.whiteSpace = "nowrap";
          el.style.overflow = "hidden";
          el.style.textOverflow = "ellipsis";
          const parentWidth = el.clientWidth;
          const parentHeight = el.clientHeight;
          while (
            (el.scrollWidth > parentWidth || el.scrollHeight > parentHeight) &&
            fontSize > minFontSize
          ) {
            fontSize -= 1;
            el.style.fontSize = fontSize + "px";
          }
          el.style.display = "flex";
          el.style.alignItems = "center";
          el.style.justifyContent = "center";
          el.style.textAlign = "center";
        }

        function renderGrid(wordObjects, N) {
          if (
            settings.enable3d &&
            N >= 3 &&
            wordObjects.length <= itemsPerPage
          ) {
            grid.style.display = "none";
            canvasContainer.style.display = "block";
            if (!scene) initThreeJS();
            render3DVisualization(wordObjects, N);
          } else {
            renderVirtualizedGrid(wordObjects);
          }
        }

        function renderVirtualizedGrid(wordObjects) {
          const columns = 2;
          const gap = 8;
          canvasContainer.style.display = "none";
          grid.style.display = "block";
          grid.innerHTML = "";
          const rowHeight = 72;
          const buffer = 4;
          const gridWidth = grid.clientWidth;
          const cellWidth = (gridWidth - (columns - 1) * gap) / columns;
          const totalRows = Math.ceil(wordObjects.length / columns);
          grid.style.position = "relative";
          grid.style.height =
            totalRows * rowHeight + (totalRows - 1) * gap + "px";
          const pool = {};
          function renderVisible() {
            const scrollTop = grid.scrollTop;
            const clientHeight = grid.clientHeight;
            const rowSize = rowHeight + gap;
            const firstRow = Math.max(
              0,
              Math.floor(scrollTop / rowSize) - buffer,
            );
            const lastRow = Math.min(
              totalRows,
              Math.ceil((scrollTop + clientHeight) / rowSize) + buffer,
            );
            const newStart = firstRow * columns;
            const newEnd = Math.min(wordObjects.length, lastRow * columns);
            for (let k in pool) {
              const i = parseInt(k);
              if (i < newStart || i >= newEnd) {
                if (grid.contains(pool[i])) grid.removeChild(pool[i]);
                delete pool[i];
              }
            }
            for (let i = newStart; i < newEnd; i++) {
              if (!pool[i]) {
                const wordObject = wordObjects[i];
                if (!wordObject) continue;
                const row = Math.floor(i / columns),
                  col = i % columns;
                const cell = document.createElement("div");
                cell.className = "cell";
                cell.dataset.index = wordObject.index;
                cell.textContent = wordObject.word;
                cell.style.position = "absolute";
                cell.style.top = row * (rowHeight + gap) + "px";
                cell.style.left = col * (cellWidth + gap) + "px";
                cell.style.width = cellWidth + "px";
                cell.style.height = rowHeight + "px";
                cell.style.boxSizing = "border-box";
                cell.addEventListener("click", () =>
                  speakSingle(wordObject.word, cell),
                );
                grid.appendChild(cell);
                fitText(cell);
                pool[i] = cell;
              }
            }
          }
          grid.onscroll = renderVisible;
          renderVisible();
          grid._scrollToIndex = function scrollToIndex(localPageIndex) {
            const targetRow = Math.floor(localPageIndex / columns);
            const rowSize = rowHeight + gap;
            const y = targetRow * rowSize;
            const viewportHeight = grid.clientHeight;
            const offset = viewportHeight / 2 - rowHeight / 2;
            grid.scrollTo({ top: y - offset, behavior: "smooth" });
          };
        }

        function render3DVisualization(wordObjects, numDimensions) {
          initThreeJS();
          wordButtons.forEach((b) => scene.remove(b));
          wordButtons = [];
          let positions = generatePositions(numDimensions, wordObjects.length);
          dimensionInfo.textContent =
            numDimensions === 3 ? `3D Kubus` : `${numDimensions}D Hyperkubus`;
          wordObjects.forEach((wordObject, i) => {
            if (i < positions.length) {
              const btn = createWordButton(
                wordObject.word,
                positions[i],
                wordObject.index,
              );
              scene.add(btn);
              wordButtons.push(btn);
            }
          });
        }

        // --- Speech Synthesis ---
        const speakWord = (text, onend) => {
          const u = new SpeechSynthesisUtterance(text);
          u.rate = settings.rate;
          u.pitch = settings.pitch;
          u.volume = 1.0;
          u.lang = settings.language || "nl-NL";
          const voices = speechSynthesis.getVoices() || [];
          const preferredVoice = voices.find((v) => v.lang === u.lang);
          if (preferredVoice) u.voice = preferredVoice;
          u.onend = onend;
          speechSynthesis.speak(u);
        };

        const clearActive = () => {
          document
            .querySelectorAll(".cell.active, .cell.valid, .cell.invalid")
            .forEach((el) => el.classList.remove("active", "valid", "invalid"));
          wordButtons.forEach((button) => {
            if (button.userData && button.userData.baseMaterial) {
              button.children[0].material = button.userData.baseMaterial;
            }
          });
        };

        const stopSpeech = (silent = false) => {
          speaking = false;
          currentPlaybackId = null;
          speechSynthesis.cancel();
          if (!silent) clearActive();
        };

        const speakSingle = (word, element) => {
          stopSpeech(true);
          clearActive();
          let highlightClass = "active";
          let highlightMaterial = activeMaterial;
          if (settings.enableValidationHighlight && wordlistLoaded) {
            const isValid = wordlist.has(word.toLowerCase());
            highlightClass = isValid ? "valid" : "invalid";
            highlightMaterial = isValid ? validMaterial : invalidMaterial;
          }
          if (element.userData && element.userData.baseMaterial) {
            // 3D
            const original = element.userData.baseMaterial;
            element.children[0].material = highlightMaterial;
            speakWord(word, () => {
              if (element && element.children && element.children[0])
                element.children[0].material = original;
            });
          } else {
            // 2D
            element.classList.add(highlightClass);
            speakWord(word, () =>
              element.classList.remove("active", "valid", "invalid"),
            );
          }
        };

        // --- Word Processing Logic ---
        const findVowelGroups = (word) => {
          const activeVowelGroups = getActiveVowelGroups();
          const lower = word.toLowerCase();
          const matches = [];
          let i = 0;
          while (i < lower.length) {
            let found = null;
            for (const vg of activeVowelGroups)
              if (lower.startsWith(vg, i)) {
                found = vg;
                break;
              }
            if (found) {
              matches.push({ group: found, index: i, length: found.length });
              i += found.length;
            } else i++;
          }
          return matches;
        };

        const analyzeWord = (raw) => {
          const word = (raw || "").trim();
          if (!/^[A-Za-z\s]+$/.test(word)) return { ok: false };
          const groups = findVowelGroups(word);
          const uniqueGroups = [...new Set(groups.map((g) => g.group))];
          if (uniqueGroups.length < 2) return { ok: false };
          return { ok: true, word, groups, uniqueGroups };
        };

        function updatePaginationControls() {
          const totalPages = Math.ceil(totalCombinations / itemsPerPage);
          prevPageBtn.disabled = currentPage <= 1;
          nextPageBtn.disabled = currentPage >= totalPages;
          prevPageBtn.style.opacity = prevPageBtn.disabled ? 0.4 : 1;
          nextPageBtn.style.opacity = nextPageBtn.disabled ? 0.4 : 1;
        }

        function buildNthVariant(n, analysis) {
          const { word, groups, uniqueGroups } = analysis;
          const base = uniqueGroups.length;
          let comboVowels = [];
          let tempN = n;
          for (let i = 0; i < groups.length; i++) {
            comboVowels.push(uniqueGroups[tempN % base]);
            tempN = Math.floor(tempN / base);
          }
          let result = "",
            pos = 0;
          for (let i = 0; i < groups.length; i++) {
            const group = groups[i];
            result += word.slice(pos, group.index) + comboVowels[i];
            pos = group.index + group.length;
          }
          result += word.slice(pos);
          return result;
        }

        function displayPage(page) {
          const totalPages = Math.ceil(totalCombinations / itemsPerPage);
          if (page < 1 || page > totalPages) return;
          currentPage = page;
          const startIndex = (page - 1) * itemsPerPage;
          const endIndex = Math.min(
            startIndex + itemsPerPage,
            totalCombinations,
          );
          const pageObjects = [];
          for (let i = startIndex; i < endIndex; i++) {
            const originalIndex = combinationOrder[i];
            pageObjects.push({
              word: buildNthVariant(originalIndex, currentAnalysis),
              index: i,
            });
          }
          renderGrid(pageObjects, currentAnalysis.uniqueGroups.length);
          comboCount.textContent = `${totalCombinations.toLocaleString("nl-NL")} combinaties`;
          pageIndicator.textContent = `Pagina ${currentPage} / ${totalPages.toLocaleString("nl-NL")}`;

          const showPagination = totalPages > 1;
          pageIndicator.style.display = showPagination ? "inline" : "none";
          prevPageBtn.style.display = showPagination ? "inline-flex" : "none";
          nextPageBtn.style.display = showPagination ? "inline-flex" : "none";

          updatePaginationControls();
        }

        function playPaginatedTwoPass() {
          stopSpeech(true);
          const playbackId = Date.now();
          currentPlaybackId = playbackId;
          speaking = true;

          const startIndex = (currentPage - 1) * itemsPerPage;
          const endIndex = Math.min(
            startIndex + itemsPerPage,
            totalCombinations,
          );
          const wordsOnPage = [];
          for (let i = startIndex; i < endIndex; i++) {
            const originalIndex = combinationOrder[i];
            wordsOnPage.push(buildNthVariant(originalIndex, currentAnalysis));
          }

          const is3D =
            settings.enable3d && canvasContainer.style.display !== "none";

          const executeSpeakingPass = (onComplete) => {
            let index = 0;
            const step = () => {
              if (currentPlaybackId !== playbackId || !speaking) {
                clearActive();
                if (currentPlaybackId === null) speaking = false;
                return;
              }
              if (index >= wordsOnPage.length) {
                clearActive();
                onComplete();
                return;
              }

              const word = wordsOnPage[index];
              const globalIndex = startIndex + index;
              clearActive();

              if (is3D) {
                const button = wordButtons.find(
                  (b) => b.userData.index === globalIndex,
                );
                if (button) button.children[0].material = activeMaterial;
              } else {
                if (grid._scrollToIndex) grid._scrollToIndex(index);
                const findAndHighlight = (attempt = 0) => {
                  if (attempt > 15) return;
                  const cell = grid.querySelector(
                    `[data-index='${globalIndex}']`,
                  );
                  if (cell) cell.classList.add("active");
                  else
                    requestAnimationFrame(() => findAndHighlight(attempt + 1));
                };
                findAndHighlight();
              }

              speakWord(word, () => {
                index++;
                step();
              });
            };
            step();
          };

          const executeValidationPass = (onComplete) => {
            let index = 0;
            const step = () => {
              if (currentPlaybackId !== playbackId) {
                return;
              }
              if (index >= wordsOnPage.length) {
                onComplete();
                return;
              }

              const word = wordsOnPage[index];
              const globalIndex = startIndex + index;

              if (is3D) {
                const button = wordButtons.find(
                  (b) => b.userData.index === globalIndex,
                );
                if (button) {
                  if (wordlist.has(word.toLowerCase())) {
                    button.children[0].material = validMaterial;
                  } else {
                    button.children[0].material = invalidMaterial;
                  }
                }
              } else {
                if (grid._scrollToIndex) grid._scrollToIndex(index);
                const findAndValidate = (attempt = 0) => {
                  if (attempt > 15) return;
                  const cell = grid.querySelector(
                    `[data-index='${globalIndex}']`,
                  );
                  if (cell) {
                    if (wordlist.has(word.toLowerCase())) {
                      cell.classList.add("valid", "bounce");
                    } else {
                      cell.classList.add("invalid", "shake");
                    }
                    setTimeout(
                      () => cell.classList.remove("bounce", "shake"),
                      500,
                    );
                  } else {
                    requestAnimationFrame(() => findAndValidate(attempt + 1));
                  }
                };
                findAndValidate();
              }

              if (wordlist.has(word.toLowerCase())) {
                correctSound.currentTime = 0;
                correctSound.play().catch((e) => console.error(e));
              } else {
                wrongSound.currentTime = 0;
                wrongSound.play().catch((e) => console.error(e));
              }

              index++;
              setTimeout(step, 500);
            };
            step();
          };

          executeSpeakingPass(() => {
            if (currentPlaybackId !== playbackId) return;
            setTimeout(() => {
              executeValidationPass(() => {
                if (currentPlaybackId !== playbackId) return;
                const totalPages = Math.ceil(totalCombinations / itemsPerPage);
                if (speaking && currentPage < totalPages) {
                  currentPage++;
                  displayPage(currentPage);
                  setTimeout(playPaginatedTwoPass, 250);
                } else {
                  speaking = false;
                }
              });
            }, 250);
          });
        }

        function playCurrentPage() {
          stopSpeech(true);
          const playbackId = Date.now();
          currentPlaybackId = playbackId;
          speaking = true;
          const startIndex = (currentPage - 1) * itemsPerPage;
          const wordsOnPage = [];
          const endIndex = Math.min(
            startIndex + itemsPerPage,
            totalCombinations,
          );
          for (let i = startIndex; i < endIndex; i++) {
            const originalIndex = combinationOrder[i];
            wordsOnPage.push(buildNthVariant(originalIndex, currentAnalysis));
          }
          const step = (idx) => {
            if (currentPlaybackId !== playbackId || !speaking) {
              clearActive();
              if (currentPlaybackId === null) speaking = false;
              return;
            }
            if (idx >= wordsOnPage.length) {
              clearActive();
              const totalPages = Math.ceil(totalCombinations / itemsPerPage);
              if (speaking && currentPage < totalPages) {
                currentPage++;
                displayPage(currentPage);
                setTimeout(playCurrentPage, 250);
              } else {
                speaking = false;
              }
              return;
            }
            const word = wordsOnPage[idx];
            const globalIndex = startIndex + idx;
            clearActive();
            const highlightClass = "active";
            const highlightMaterial = activeMaterial;
            if (settings.enable3d && canvasContainer.style.display !== "none") {
              const button = wordButtons.find(
                (b) => b.userData.index === globalIndex,
              );
              if (button) button.children[0].material = highlightMaterial;
            } else if (grid.style.display !== "none") {
              if (grid._scrollToIndex) grid._scrollToIndex(idx);
              const highlightWhenVisible = (attempt = 0) => {
                if (attempt > 15) return;
                const cell = grid.querySelector(
                  `[data-index='${globalIndex}']`,
                );
                if (cell) {
                  cell.classList.add(highlightClass);
                } else {
                  requestAnimationFrame(() =>
                    highlightWhenVisible(attempt + 1),
                  );
                }
              };
              highlightWhenVisible();
            }
            speakWord(word, () => step(idx + 1));
          };
          step(0);
        }

        const showError = () => {
          stopSpeech(true);
          paginationControls.style.display = "none";
          if (!modal.open) modal.showModal();
          const u = new SpeechSynthesisUtterance("Neehee");
          const voices = speechSynthesis.getVoices() || [];
          const dutchVoice =
            voices.find((v) => /^nl(-|$)/i.test(v.lang)) ||
            voices.find((v) => /dutch|nederlands/i.test(v.name));
          if (dutchVoice) u.voice = dutchVoice;
          u.lang = "nl-NL";
          u.rate = 1;
          u.pitch = 0.9;
          speechSynthesis.speak(u);
        };

        function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
        }

        function handleRandomWordGeneration() {
          if (!wordlistLoaded || wordlist.size === 0) {
            console.warn("Wordlist not loaded yet.");
            return;
          }

          const wordArray = Array.from(wordlist);
          let randomWord = null;
          let attempts = 0;
          const maxAttempts = 200;

          while (attempts < maxAttempts) {
            const candidate =
              wordArray[Math.floor(Math.random() * wordArray.length)];
            const analysis = analyzeWord(candidate);
            if (analysis.ok) {
              randomWord = candidate;
              break;
            }
            attempts++;
          }

          if (randomWord) {
            input.value = randomWord;
            document.getElementById("generate").click();
          } else {
            alert(
              "Kon geen geschikt willekeurig woord vinden. Probeer het opnieuw.",
            );
            console.error(
              `Failed to find a valid random word after ${maxAttempts} attempts.`,
            );
          }
        }

        // --- Event Listeners & Initialization ---
        closeModal.addEventListener("click", () => {
          if (modal.open) modal.close();
          input.focus();
          input.select();
        });

        randomizeBtn.addEventListener("click", () => {
          if (combinationOrder.length > 0) {
            stopSpeech();
            shuffleArray(combinationOrder);
            displayPage(1);
          }
        });

        shareBtn.addEventListener("click", async () => {
          if (!currentAnalysis || !currentAnalysis.ok) {
            input.animate(
              [
                { transform: "translateX(0)" },
                { transform: "translateX(-5px)" },
                { transform: "translateX(5px)" },
                { transform: "translateX(0)" },
              ],
              { duration: 300, easing: "ease-in-out" },
            );
            input.focus();
            return;
          }
          const wordToShare = input.value.trim();
          if (!wordToShare) return;
          const compressed = compressSettings(settings);
          const baseUrl = window.location.origin + window.location.pathname;
          let shareUrl = `${baseUrl}?word=${encodeURIComponent(wordToShare)}`;
          if (Object.keys(compressed).length > 0) {
            const settingsString = JSON.stringify(compressed);
            const encodedSettings = btoa(settingsString);
            shareUrl += `&s=${encodeURIComponent(encodedSettings)}`;
          }
          const shareData = {
            title: "Barend Generator",
            text: `Bekijk het Barendogram voor "${wordToShare}"`,
            url: shareUrl,
          };
          if (navigator.share && navigator.canShare(shareData)) {
            try {
              await navigator.share(shareData);
            } catch (err) {
              console.error("Share failed:", err);
            }
          } else {
            try {
              await navigator.clipboard.writeText(shareUrl);
              const originalIcon = shareBtn.innerHTML;
              shareBtn.innerHTML = "‚úÖ";
              setTimeout(() => {
                shareBtn.innerHTML = originalIcon;
              }, 2000);
            } catch (err) {
              alert("Kon de link niet naar het klembord kopi√´ren.");
            }
          }
        });

        function proceedWithGeneration() {
          currentAnalysis = window._pendingAnalysis;
          currentAnalysis.settingsSnapshot = JSON.stringify(
            getActiveVowelGroups(),
          );
          totalCombinations = Math.pow(
            currentAnalysis.uniqueGroups.length,
            currentAnalysis.groups.length,
          );
          combinationOrder = Array.from(
            { length: totalCombinations },
            (_, i) => i,
          );

          const isBarendroom = checkAllWordsExist(currentAnalysis);

          if (isBarendroom) {
            startBarendroomSequence(currentAnalysis);
          } else {
            outputCard.style.display = "block";
            paginationControls.style.display =
              totalCombinations > 0 ? "flex" : "none";
            displayPage(1);
            if (settings.enableValidationHighlight && wordlistLoaded) {
              playPaginatedTwoPass();
            } else {
              playCurrentPage();
            }
          }
          randomizeBtn.style.display =
            totalCombinations > 1 && !isBarendroom ? "inline-flex" : "none";
          window._pendingAnalysis = null;
        }

        function showWarningModal(check) {
          const numGroups = check.uniqueGroups.length;
          const estimatedTotal = Math.pow(numGroups, check.groups.length);
          const warningMessage = `Je staat op het punt een ${numGroups}D hyperkubus te genereren met ${estimatedTotal.toLocaleString("nl-NL")} combinaties in 3D-modus. Dit kan erg traag zijn of de browser laten crashen. Weet je het zeker?`;
          warningModalText.textContent = warningMessage;
          warningModal.showModal();
          window._pendingAnalysis = check;
        }

        form.addEventListener("submit", (e) => {
          e.preventDefault();
          const newWord = input.value.trim();
          const currentActiveVowels = JSON.stringify(getActiveVowelGroups());

          if (
            currentAnalysis.ok &&
            newWord.toLowerCase() === currentAnalysis.word.toLowerCase() &&
            currentAnalysis.settingsSnapshot === currentActiveVowels
          ) {
            if (totalCombinations > 0) {
              if (checkAllWordsExist(currentAnalysis)) {
                startBarendroomSequence(currentAnalysis);
              } else if (settings.enableValidationHighlight && wordlistLoaded) {
                playPaginatedTwoPass();
              } else {
                playCurrentPage();
              }
            }
          } else {
            const check = analyzeWord(newWord);
            if (!check.ok) {
              showError();
              return;
            }
            if (settings.enable3d && check.uniqueGroups.length > 3) {
              showWarningModal(check);
            } else {
              window._pendingAnalysis = check;
              proceedWithGeneration();
            }
          }
        });

        if (randomWordBtn) {
          randomWordBtn.addEventListener("click", handleRandomWordGeneration);
        }

        confirmProceedBtn.addEventListener("click", () => {
          warningModal.close();
          if (window._pendingAnalysis) {
            proceedWithGeneration();
          }
        });
        confirmCancelBtn.addEventListener("click", () => {
          warningModal.close();
          window._pendingAnalysis = null;
        });
        btnStop.addEventListener("click", () => stopSpeech());
        prevPageBtn.addEventListener("click", () => {
          if (currentPage > 1) {
            stopSpeech();
            displayPage(currentPage - 1);
          }
        });
        nextPageBtn.addEventListener("click", () => {
          const totalPages = Math.ceil(totalCombinations / itemsPerPage);
          if (currentPage < totalPages) {
            stopSpeech();
            displayPage(currentPage + 1);
          }
        });

        pageIndicator.addEventListener("click", () => {
          if (document.getElementById("page-input")) return;
          pageIndicator.style.display = "none";
          const pageInput = document.createElement("input");
          pageInput.id = "page-input";
          pageInput.type = "number";
          pageInput.value = currentPage;
          pageInput.min = 1;
          const totalPages = Math.ceil(totalCombinations / itemsPerPage);
          pageInput.max = totalPages;
          pageInput.style.cssText = `width:${totalPages.toString().length * 10 + 30}px; min-width:50px; text-align:center; background:rgba(0,0,0,0.3); border:1px solid var(--muted); color:var(--text); border-radius:6px; padding:2px 4px;`;
          const revertToSpan = () => {
            if (pageIndicator.parentNode.contains(pageInput))
              pageIndicator.parentNode.removeChild(pageInput);
            pageIndicator.style.display = "inline";
          };
          pageInput.addEventListener("blur", revertToSpan);
          pageInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              const newPage = parseInt(pageInput.value, 10);
              if (!isNaN(newPage) && newPage >= 1 && newPage <= totalPages) {
                stopSpeech();
                displayPage(newPage);
              }
              revertToSpan();
            } else if (e.key === "Escape") {
              revertToSpan();
            }
          });
          pageIndicator.parentNode.insertBefore(pageInput, randomizeBtn);
          pageInput.focus();
          pageInput.select();
        });
        optionsBtn.addEventListener("click", () => optionsModal.showModal());
        closeOptionsModal.addEventListener("click", () => optionsModal.close());
        leaderboardBtn.addEventListener("click", () => {
          leaderboardModal.showModal();
          if (leaderboardBody.innerHTML.trim() === "") {
            loadLeaderboard();
          }
        });
        closeLeaderboardModal.addEventListener("click", () =>
          leaderboardModal.close(),
        );
        spoilerCancelBtn.addEventListener("click", () => {
          spoilerWarningModal.close();
          _pendingSpoilerReveal = null;
        });
        spoilerConfirmBtn.addEventListener("click", () => {
          if (_pendingSpoilerReveal) {
            const { cell, word } = _pendingSpoilerReveal;
            cell.innerHTML = ""; // Clear the "Show" button

            const wordSpan = document.createElement("span");
            wordSpan.textContent = word;
            wordSpan.className = "clickable-barendroom";
            wordSpan.addEventListener("click", () => {
              input.value = word;
              leaderboardModal.close();
              spoilerWarningModal.close();
              form.dispatchEvent(new Event("submit"));
            });

            cell.appendChild(wordSpan);
          }

          spoilerWarningModal.close();
          _pendingSpoilerReveal = null;
        });
        helpBtn.addEventListener("click", () => instructionsModal.showModal());
        closeInstructionsModal.addEventListener("click", () =>
          instructionsModal.close(),
        );

        definitionsBtn.addEventListener("click", () => {
          definitionsModal.showModal();
          loadDefinitions(); // Only load definitions when this modal is opened
        });
        closeDefinitionsModal.addEventListener("click", () =>
          definitionsModal.close(),
        );

        document
          .getElementById("definitions-container")
          .addEventListener("click", (e) => {
            if (e.target.classList.contains("def-link")) {
              const term = e.target.dataset.term;
              if (!term) return;

              const targetId =
                "def-term-" + term.toLowerCase().replace(/\s+/g, "-");
              const targetElement = document.getElementById(targetId);

              if (targetElement) {
                targetElement.scrollIntoView({
                  behavior: "smooth",
                  block: "center",
                });

                // Highlight the term and its definition
                const targetDd = targetElement.nextElementSibling;
                targetElement.classList.add("highlight-def");
                if (targetDd) {
                  targetDd.classList.add("highlight-def");
                }

                setTimeout(() => {
                  targetElement.classList.remove("highlight-def");
                  if (targetDd) {
                    targetDd.classList.remove("highlight-def");
                  }
                }, 1500);
              }
            }
          });
        enable3dCheckbox.addEventListener("change", saveSettings);
        enableValidationHighlightCheckbox.addEventListener(
          "change",
          saveSettings,
        );
        languageSelect.addEventListener("change", saveSettings);
        pitchSlider.addEventListener("input", () => {
          updateSliderValues();
          saveSettings();
        });
        rateSlider.addEventListener("input", () => {
          updateSliderValues();
          saveSettings();
        });
        resetSettingsBtn.addEventListener("click", () => {
          applySettings(JSON.parse(JSON.stringify(defaultSettings)));
          saveSettings();
        });
        vowelOptionsDetails.addEventListener("toggle", saveSettings);
        vowelsSelectAllBtn.addEventListener("click", () => {
          vowelGroupGrid
            .querySelectorAll(".toggle-switch")
            .forEach((toggle) => (toggle.checked = true));
          saveSettings();
        });
        vowelsSelectNoneBtn.addEventListener("click", () => {
          vowelGroupGrid
            .querySelectorAll(".toggle-switch")
            .forEach((toggle) => (toggle.checked = false));
          saveSettings();
        });
        vowelGroupGrid.addEventListener("change", (e) => {
          if (e.target.matches(".toggle-switch")) saveSettings();
        });

        function populateVowelOptions() {
          vowelGroupGrid.innerHTML = "";
          TWO_LETTER_VOWELS.forEach((vg) => {
            const id = `vowel-toggle-${vg}`;
            const item = document.createElement("div");
            item.className = "vowel-group-item";
            item.innerHTML = `<label for="${id}">${vg}</label><input type="checkbox" id="${id}" data-vowel-group="${vg}" class="toggle-switch">`;
            vowelGroupGrid.appendChild(item);
          });
        }

        function populateLanguageOptions() {
          const voices = speechSynthesis.getVoices();
          if (!voices.length) return;
          const langDisplayNames = new Intl.DisplayNames(["nl"], {
            type: "language",
          });
          const uniqueLangs = [
            ...new Map(voices.map((v) => [v.lang, v])).values(),
          ].sort((a, b) => a.lang.localeCompare(b.lang));
          const savedLang = settings.language;
          languageSelect.innerHTML = "";
          uniqueLangs.forEach((voice) => {
            if (!voice || !voice.lang) return;
            const option = document.createElement("option");
            option.value = voice.lang;
            let langName;
            try {
              langName = langDisplayNames.of(voice.lang.split("-")[0]);
            } catch (e) {
              console.warn(`Invalid language code found: "${voice.lang}"`);
              langName = voice.lang;
            }
            option.textContent = `${langName} (${voice.lang})`;
            languageSelect.appendChild(option);
          });
          if ([...languageSelect.options].some((o) => o.value === savedLang)) {
            languageSelect.value = savedLang;
          } else {
            const dutchVoice = uniqueLangs.find((v) => v.lang.startsWith("nl"));
            if (dutchVoice) languageSelect.value = dutchVoice.lang;
          }
          settings.language = languageSelect.value;
        }
        speechSynthesis.onvoiceschanged = populateLanguageOptions;

        function initializeFromUrl() {
          const urlParams = new URLSearchParams(window.location.search);
          const wordFromUrl = urlParams.get("word");
          const settingsFromUrl = urlParams.get("s");
          if (settingsFromUrl) {
            try {
              const decodedSettings = atob(decodeURIComponent(settingsFromUrl));
              const compressed = JSON.parse(decodedSettings);
              const fullSettings = decompressSettings(compressed);
              applySettings(fullSettings);
              localStorage.setItem(
                "barendGenSettings",
                JSON.stringify(fullSettings),
              );
            } catch (e) {
              console.error(
                "Failed to parse settings from URL, loading defaults.",
                e,
              );
              loadSettings();
            }
          } else {
            loadSettings();
          }
          if (wordFromUrl) {
            input.value = wordFromUrl;
            setTimeout(() => {
              document.getElementById("generate").click();
            }, 250);
          }
        }

        // --- Final Initialization ---
        input.setAttribute("autofocus", "true");
        loadWordlist();
        populateVowelOptions();
        initializeFromUrl();
        populateLanguageOptions();
      })();
    </script>
  </body>
</html>
